import AsyncStorage from '@react-native-async-storage/async-storage';
import { guestUpgradeService } from './guestUpgradeService';

/**
 * æ¸¸å®¢æ•°æ®æ¸…ç†æµ‹è¯•æœåŠ¡
 * ç”¨äºæµ‹è¯•å’ŒéªŒè¯æ¸¸å®¢æ•°æ®æ¸…ç†åŠŸèƒ½
 */
export class GuestDataCleanupTest {
  private static instance: GuestDataCleanupTest;

  private constructor() {}

  public static getInstance(): GuestDataCleanupTest {
    if (!GuestDataCleanupTest.instance) {
      GuestDataCleanupTest.instance = new GuestDataCleanupTest();
    }
    return GuestDataCleanupTest.instance;
  }

  /**
   * åˆ›å»ºæµ‹è¯•æ¸¸å®¢æ•°æ®
   */
  public async createTestGuestData(): Promise<void> {
    try {
      console.log('[GuestDataCleanupTest] ğŸ§ª åˆ›å»ºæµ‹è¯•æ¸¸å®¢æ•°æ®...');
      
      const testData = {
        // æ¸¸å®¢æ•°æ®
        'guest_vocabulary': JSON.stringify([
          { word: 'hello', meaning: 'ä½ å¥½', learned: true },
          { word: 'world', meaning: 'ä¸–ç•Œ', learned: false }
        ]),
        'guest_learningRecords': JSON.stringify([
          { wordId: '1', word: 'hello', reviewCount: 3, correctCount: 2 }
        ]),
        'guest_userStats': JSON.stringify({
          totalWords: 2,
          streakDays: 5,
          level: 2
        }),
        'guest_searchHistory': JSON.stringify([
          { word: 'hello', timestamp: Date.now() }
        ]),
        'guest_shows': JSON.stringify([
          { id: 1, name: 'Test Show', words: ['hello', 'world'] }
        ]),
        'guest_experienceGain': '150',
        'guest_experienceEvents': JSON.stringify([
          { type: 'word_learned', xp: 10, timestamp: Date.now() }
        ]),
        'guest_wordbooks': JSON.stringify([
          { id: 1, name: 'Test Book', words: ['hello'] }
        ]),
        'guest_badges': JSON.stringify([
          { id: 'first_word', name: 'First Word', unlocked: true }
        ]),
        'guest_userSettings': JSON.stringify({
          language: 'en',
          notifications: true
        }),
        
        // æ¸¸å®¢é…ç½®
        'guestConfig': JSON.stringify({
          guestId: 'test_guest_123',
          createdAt: Date.now()
        }),
        'guestData': JSON.stringify({
          totalSize: 1024,
          lastActive: Date.now()
        }),
        'guestMode': 'true',
        'autoGeneratedGuestId': 'test_guest_123',
        
        // æ¸¸å®¢åŒæ­¥æ•°æ®
        'guest_syncQueue': JSON.stringify([]),
        'guest_localDataVersions': JSON.stringify({}),
        'guest_lastSyncTime': Date.now().toString(),
        
        // æ¸¸å®¢ç¼“å­˜
        'guest_wordDataCache': JSON.stringify({}),
        'guest_searchCache': JSON.stringify({}),
        'guest_showCache': JSON.stringify({}),
        
        // æ¸¸å®¢ä¸´æ—¶æ•°æ®
        'guest_tempData': JSON.stringify({ temp: 'data' }),
        'guest_backupData': JSON.stringify({ backup: 'data' }),
        'guest_migrationData': JSON.stringify({ migration: 'data' }),
        
        // æ¸¸å®¢IDç›¸å…³
        'guestId': 'test_guest_123',
        'cachedGuestId': 'test_guest_123',
        'lastGuestId': 'test_guest_123',
        'guestIdTimestamp': Date.now().toString(),
        'guestIdGenerated': 'true'
      };

      // ä¿å­˜æµ‹è¯•æ•°æ®
      const entries = Object.entries(testData);
      for (const [key, value] of entries) {
        await AsyncStorage.setItem(key, value);
      }

      console.log(`[GuestDataCleanupTest] âœ… å·²åˆ›å»º ${entries.length} ä¸ªæµ‹è¯•æ•°æ®é¡¹`);
      
    } catch (error) {
      console.error('[GuestDataCleanupTest] âŒ åˆ›å»ºæµ‹è¯•æ•°æ®å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * éªŒè¯æ¸¸å®¢æ•°æ®æ˜¯å¦å­˜åœ¨
   */
  public async verifyGuestDataExists(): Promise<{
    exists: boolean;
    count: number;
    keys: string[];
  }> {
    try {
      const allKeys = await AsyncStorage.getAllKeys();
      const guestKeys = allKeys.filter(key => 
        key.startsWith('guest_') || 
        key.includes('guest') ||
        key === 'guestConfig' ||
        key === 'guestData' ||
        key === 'guestMode' ||
        key === 'autoGeneratedGuestId' ||
        key === 'guestId' ||
        key === 'cachedGuestId' ||
        key === 'lastGuestId' ||
        key === 'guestIdTimestamp' ||
        key === 'guestIdGenerated'
      );

      return {
        exists: guestKeys.length > 0,
        count: guestKeys.length,
        keys: guestKeys
      };
      
    } catch (error) {
      console.error('[GuestDataCleanupTest] âŒ éªŒè¯æ¸¸å®¢æ•°æ®å¤±è´¥:', error);
      return {
        exists: false,
        count: 0,
        keys: []
      };
    }
  }

  /**
   * æµ‹è¯•æ¸…ç†åŠŸèƒ½
   */
  public async testCleanupFunction(): Promise<{
    success: boolean;
    beforeCount: number;
    afterCount: number;
    message: string;
  }> {
    try {
      console.log('[GuestDataCleanupTest] ğŸ§ª å¼€å§‹æµ‹è¯•æ¸…ç†åŠŸèƒ½...');
      
      // 1. åˆ›å»ºæµ‹è¯•æ•°æ®
      await this.createTestGuestData();
      
      // 2. éªŒè¯æ•°æ®å­˜åœ¨
      const beforeVerification = await this.verifyGuestDataExists();
      console.log(`[GuestDataCleanupTest] ğŸ“Š æ¸…ç†å‰æ¸¸å®¢æ•°æ®: ${beforeVerification.count} é¡¹`);
      
      // 3. æ‰§è¡Œæ¸…ç†
      const cleanupResult = await guestUpgradeService.clearGuestDataManually();
      
      // 4. éªŒè¯æ¸…ç†ç»“æœ
      const afterVerification = await this.verifyGuestDataExists();
      console.log(`[GuestDataCleanupTest] ğŸ“Š æ¸…ç†åæ¸¸å®¢æ•°æ®: ${afterVerification.count} é¡¹`);
      
      const success = cleanupResult.success && afterVerification.count === 0;
      
      return {
        success,
        beforeCount: beforeVerification.count,
        afterCount: afterVerification.count,
        message: success 
          ? `âœ… æ¸…ç†æµ‹è¯•æˆåŠŸï¼æ¸…ç†äº† ${beforeVerification.count} é¡¹æ•°æ®`
          : `âŒ æ¸…ç†æµ‹è¯•å¤±è´¥ï¼æ¸…ç†å‰: ${beforeVerification.count} é¡¹ï¼Œæ¸…ç†å: ${afterVerification.count} é¡¹`
      };
      
    } catch (error) {
      console.error('[GuestDataCleanupTest] âŒ æµ‹è¯•æ¸…ç†åŠŸèƒ½å¤±è´¥:', error);
      return {
        success: false,
        beforeCount: 0,
        afterCount: 0,
        message: `âŒ æµ‹è¯•å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      };
    }
  }

  /**
   * è¿è¡Œå®Œæ•´çš„æ¸…ç†æµ‹è¯•å¥—ä»¶
   */
  public async runFullTestSuite(): Promise<{
    success: boolean;
    results: Array<{
      testName: string;
      success: boolean;
      message: string;
    }>;
  }> {
    try {
      console.log('[GuestDataCleanupTest] ğŸ§ª å¼€å§‹è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶...');
      
      const results: Array<{
        testName: string;
        success: boolean;
        message: string;
      }> = [];

      // æµ‹è¯•1: åˆ›å»ºæµ‹è¯•æ•°æ®
      try {
        await this.createTestGuestData();
        results.push({
          testName: 'åˆ›å»ºæµ‹è¯•æ•°æ®',
          success: true,
          message: 'âœ… æµ‹è¯•æ•°æ®åˆ›å»ºæˆåŠŸ'
        });
      } catch (error) {
        results.push({
          testName: 'åˆ›å»ºæµ‹è¯•æ•°æ®',
          success: false,
          message: `âŒ æµ‹è¯•æ•°æ®åˆ›å»ºå¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
        });
      }

      // æµ‹è¯•2: éªŒè¯æ•°æ®å­˜åœ¨
      try {
        const verification = await this.verifyGuestDataExists();
        results.push({
          testName: 'éªŒè¯æ•°æ®å­˜åœ¨',
          success: verification.exists,
          message: verification.exists 
            ? `âœ… æ‰¾åˆ° ${verification.count} é¡¹æ¸¸å®¢æ•°æ®`
            : 'âŒ æœªæ‰¾åˆ°æ¸¸å®¢æ•°æ®'
        });
      } catch (error) {
        results.push({
          testName: 'éªŒè¯æ•°æ®å­˜åœ¨',
          success: false,
          message: `âŒ éªŒè¯å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
        });
      }

      // æµ‹è¯•3: æ¸…ç†åŠŸèƒ½
      try {
        const cleanupTest = await this.testCleanupFunction();
        results.push({
          testName: 'æ¸…ç†åŠŸèƒ½æµ‹è¯•',
          success: cleanupTest.success,
          message: cleanupTest.message
        });
      } catch (error) {
        results.push({
          testName: 'æ¸…ç†åŠŸèƒ½æµ‹è¯•',
          success: false,
          message: `âŒ æ¸…ç†æµ‹è¯•å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
        });
      }

      const overallSuccess = results.every(result => result.success);
      
      console.log('[GuestDataCleanupTest] ğŸ“‹ æµ‹è¯•å¥—ä»¶å®Œæˆ:', {
        overallSuccess,
        totalTests: results.length,
        passedTests: results.filter(r => r.success).length,
        failedTests: results.filter(r => !r.success).length
      });

      return {
        success: overallSuccess,
        results
      };
      
    } catch (error) {
      console.error('[GuestDataCleanupTest] âŒ è¿è¡Œæµ‹è¯•å¥—ä»¶å¤±è´¥:', error);
      return {
        success: false,
        results: [{
          testName: 'æµ‹è¯•å¥—ä»¶',
          success: false,
          message: `âŒ æµ‹è¯•å¥—ä»¶å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
        }]
      };
    }
  }
}

export const guestDataCleanupTest = GuestDataCleanupTest.getInstance();
