import AsyncStorage from '@react-native-async-storage/async-storage';
import { API_BASE_URL } from '../constants/config';
import { guestDataAdapter } from './guestDataAdapter';
import { guestModeService } from './guestModeService';

export interface GuestData {
  vocabulary?: any[];
  learningRecords?: any[];
  userStats?: any;
  searchHistory?: any[];
  shows?: any[];
  userSettings?: any;
  wrongWords?: any[];
  experienceGain?: number;
  experienceEvents?: any[];
  wordbooks?: any[];
  badges?: any[];
}

export interface UpgradeResult {
  success: boolean;
  message: string;
  migratedDataTypes: string[];
  error?: string;
}

class GuestUpgradeService {
  private static instance: GuestUpgradeService;

  public static getInstance(): GuestUpgradeService {
    if (!GuestUpgradeService.instance) {
      GuestUpgradeService.instance = new GuestUpgradeService();
    }
    return GuestUpgradeService.instance;
  }

  /**
   * è·å–æ¸¸å®¢æ•°æ®
   */
  public async getGuestData(): Promise<GuestData> {
    try {
      console.log('[GuestUpgradeService] ğŸ” å¼€å§‹è·å–æ¸¸å®¢æ•°æ®...');
      
      const data: GuestData = {};
      
      // è·å–å„ç§æ¸¸å®¢æ•°æ®
      const keys = [
        'learningRecords',
        'vocabulary', 
        'user_shows',
        'userSettings',
        'userStats',
        'wrongWords',
        'experienceGain',
        'experienceEvents',
        'wordbooks',
        'badges'
      ];
      
      for (const key of keys) {
        try {
          const value = await AsyncStorage.getItem(key);
          if (value) {
            data[key as keyof GuestData] = JSON.parse(value);
            console.log(`[GuestUpgradeService] âœ… è·å–åˆ° ${key} æ•°æ®`);
          }
        } catch (error) {
          console.error(`[GuestUpgradeService] âŒ è·å– ${key} æ•°æ®å¤±è´¥:`, error);
        }
      }
      
      console.log('[GuestUpgradeService] ğŸ“Š æ¸¸å®¢æ•°æ®ç»Ÿè®¡:', {
        vocabulary: data.vocabulary?.length || 0,
        learningRecords: data.learningRecords?.length || 0,
        userStats: data.userStats ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨',
        searchHistory: data.searchHistory?.length || 0,
        shows: data.shows?.length || 0,
        userSettings: data.userSettings ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨',
        wrongWords: data.wrongWords?.length || 0,
        experienceGain: data.experienceGain || 0,
        experienceEvents: data.experienceEvents?.length || 0,
        wordbooks: data.wordbooks?.length || 0,
        badges: data.badges?.length || 0
      });
      
      return data;
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ è·å–æ¸¸å®¢æ•°æ®å¤±è´¥:', error);
      return {};
    }
  }

  /**
   * è¿ç§»æ¸¸å®¢æ•°æ®åˆ°æ³¨å†Œç”¨æˆ·
   */
  public async migrateGuestDataToRegistered(
    newUserId: string, 
    token: string
  ): Promise<UpgradeResult> {
    try {
      console.log('[GuestUpgradeService] ğŸš€ å¼€å§‹è¿ç§»æ¸¸å®¢æ•°æ®åˆ°æ³¨å†Œç”¨æˆ·:', newUserId);
      
      // 1. è·å–æ¸¸å®¢æ•°æ®
      const guestData = await this.getGuestData();
      
      if (!guestData || Object.keys(guestData).length === 0) {
        console.log('[GuestUpgradeService] â„¹ï¸ æ²¡æœ‰æ‰¾åˆ°æ¸¸å®¢æ•°æ®ï¼Œè·³è¿‡è¿ç§»');
        return {
          success: true,
          message: 'æ²¡æœ‰æ¸¸å®¢æ•°æ®éœ€è¦è¿ç§»',
          migratedDataTypes: []
        };
      }
      
      // 2. ä¸Šä¼ æ•°æ®åˆ°åç«¯
      const uploadResult = await this.uploadGuestDataToBackend(guestData, newUserId, token);
      
      if (!uploadResult.success) {
        throw new Error(uploadResult.error || 'ä¸Šä¼ æ•°æ®å¤±è´¥');
      }
      
      // 3. ä¿å­˜æ•°æ®åˆ°æ–°ç”¨æˆ·çš„æœ¬åœ°å­˜å‚¨
      await this.saveDataToNewUser(guestData, newUserId);
      
      // 4. æ¸…ç†æ¸¸å®¢æ•°æ®
      await this.clearGuestData();
      
      console.log('[GuestUpgradeService] âœ… æ¸¸å®¢æ•°æ®è¿ç§»å®Œæˆ');
      
      return {
        success: true,
        message: 'æ¸¸å®¢æ•°æ®è¿ç§»æˆåŠŸ',
        migratedDataTypes: uploadResult.migratedDataTypes
      };
      
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ æ¸¸å®¢æ•°æ®è¿ç§»å¤±è´¥:', error);
      return {
        success: false,
        message: 'æ¸¸å®¢æ•°æ®è¿ç§»å¤±è´¥',
        migratedDataTypes: [],
        error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      };
    }
  }

  /**
   * å…¬å…±æ–¹æ³•ï¼šæ¸…ç†æ¸¸å®¢æ•°æ®ï¼ˆå¯åœ¨éœ€è¦æ—¶æ‰‹åŠ¨è°ƒç”¨ï¼‰
   */
  public async clearGuestDataManually(): Promise<{
    success: boolean;
    message: string;
    clearedKeys: number;
  }> {
    try {
      console.log('[GuestUpgradeService] ğŸ§¹ æ‰‹åŠ¨æ¸…ç†æ¸¸å®¢æ•°æ®...');
      
      const allKeys = await AsyncStorage.getAllKeys();
      const guestKeys = allKeys.filter(key => 
        key.startsWith('guest_') || 
        key.includes('guest') ||
        key === 'guestConfig' ||
        key === 'guestData' ||
        key === 'guestMode' ||
        key === 'autoGeneratedGuestId'
      );
      
      if (guestKeys.length > 0) {
        await AsyncStorage.multiRemove(guestKeys);
        console.log(`[GuestUpgradeService] âœ… æ‰‹åŠ¨æ¸…ç†å®Œæˆï¼Œå…±æ¸…ç† ${guestKeys.length} ä¸ªé”®`);
        
        return {
          success: true,
          message: `æˆåŠŸæ¸…ç† ${guestKeys.length} ä¸ªæ¸¸å®¢æ•°æ®é¡¹`,
          clearedKeys: guestKeys.length
        };
      } else {
        return {
          success: true,
          message: 'æ²¡æœ‰æ‰¾åˆ°éœ€è¦æ¸…ç†çš„æ¸¸å®¢æ•°æ®',
          clearedKeys: 0
        };
      }
      
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ æ‰‹åŠ¨æ¸…ç†æ¸¸å®¢æ•°æ®å¤±è´¥:', error);
      return {
        success: false,
        message: 'æ¸…ç†æ¸¸å®¢æ•°æ®å¤±è´¥',
        clearedKeys: 0
      };
    }
  }

  /**
   * æ¸…ç†æ¸¸å®¢æ•°æ®
   */
  private async clearGuestData(): Promise<void> {
    try {
      console.log('[GuestUpgradeService] ğŸ§¹ å¼€å§‹æ¸…ç†æ¸¸å®¢æ•°æ®...');
      
      // 1. æ¸…ç†æ¸¸å®¢æ¨¡å¼æœåŠ¡çš„æ•°æ®
      await guestModeService.clearGuestData();
      
      // 2. æ¸…ç†æ¸¸å®¢æ•°æ®é€‚é…å™¨çš„æ•°æ®
      await guestDataAdapter.clearGuestData();
      
      // 3. æ¸…ç†æ‰€æœ‰æ¸¸å®¢ç›¸å…³çš„å­˜å‚¨é”®
      await this.clearGuestStorageKeys();
      
      // 4. æ¸…ç†æ¸¸å®¢IDç›¸å…³æ•°æ®
      await this.clearGuestIdData();
      
      console.log('[GuestUpgradeService] âœ… æ¸¸å®¢æ•°æ®æ¸…ç†å®Œæˆ');
      
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ æ¸…ç†æ¸¸å®¢æ•°æ®å¤±è´¥:', error);
      // ä¸æŠ›å‡ºé”™è¯¯ï¼Œé¿å…å½±å“è¿ç§»æµç¨‹
    }
  }

  /**
   * æ¸…ç†æ¸¸å®¢å­˜å‚¨é”®
   */
  private async clearGuestStorageKeys(): Promise<void> {
    try {
      const allKeys = await AsyncStorage.getAllKeys();
      
      // å®šä¹‰éœ€è¦æ¸…ç†çš„æ¸¸å®¢ç›¸å…³é”®
      const guestKeysToRemove = [
        // æ¸¸å®¢æ•°æ®é”®
        'guest_vocabulary',
        'guest_learningRecords', 
        'guest_userStats',
        'guest_searchHistory',
        'guest_shows',
        'guest_experienceGain',
        'guest_experienceEvents',
        'guest_wordbooks',
        'guest_badges',
        'guest_userSettings',
        'guest_learningStats',
        'guest_reviewSessions',
        'guest_wrongWords',
        
        // æ¸¸å®¢é…ç½®é”®
        'guestConfig',
        'guestData',
        'guestMode',
        'autoGeneratedGuestId',
        
        // æ¸¸å®¢åŒæ­¥ç›¸å…³é”®
        'guest_syncQueue',
        'guest_localDataVersions',
        'guest_lastSyncTime',
        
        // æ¸¸å®¢ç¼“å­˜é”®
        'guest_wordDataCache',
        'guest_searchCache',
        'guest_showCache',
        
        // æ¸¸å®¢ä¸´æ—¶æ•°æ®
        'guest_tempData',
        'guest_backupData',
        'guest_migrationData'
      ];
      
      // è¿‡æ»¤å‡ºå®é™…å­˜åœ¨çš„é”®
      const existingKeys = allKeys.filter(key => 
        guestKeysToRemove.includes(key) || 
        key.startsWith('guest_') ||
        key.includes('guest')
      );
      
      if (existingKeys.length > 0) {
        await AsyncStorage.multiRemove(existingKeys);
        console.log(`[GuestUpgradeService] ğŸ—‘ï¸ å·²æ¸…ç† ${existingKeys.length} ä¸ªæ¸¸å®¢å­˜å‚¨é”®`);
      }
      
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ æ¸…ç†æ¸¸å®¢å­˜å‚¨é”®å¤±è´¥:', error);
    }
  }

  /**
   * æ¸…ç†æ¸¸å®¢IDç›¸å…³æ•°æ®
   */
  private async clearGuestIdData(): Promise<void> {
    try {
      // æ¸…ç†æ¸¸å®¢IDç›¸å…³çš„å­˜å‚¨
      const guestIdKeys = [
        'guestId',
        'cachedGuestId', 
        'lastGuestId',
        'guestIdTimestamp',
        'guestIdGenerated',
        'autoGeneratedGuestId'
      ];
      
      await AsyncStorage.multiRemove(guestIdKeys);
      console.log('[GuestUpgradeService] ğŸ†” å·²æ¸…ç†æ¸¸å®¢IDç›¸å…³æ•°æ®');
      
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ æ¸…ç†æ¸¸å®¢IDæ•°æ®å¤±è´¥:', error);
    }
  }

  /**
   * ä¸Šä¼ æ¸¸å®¢æ•°æ®åˆ°åç«¯
   */
  private async uploadGuestDataToBackend(
    guestData: GuestData, 
    userId: string, 
    token: string
  ): Promise<{ success: boolean; migratedDataTypes: string[]; error?: string }> {
    try {
      console.log('[GuestUpgradeService] ğŸ“¤ å¼€å§‹ä¸Šä¼ æ¸¸å®¢æ•°æ®åˆ°åç«¯...');
      
      const migratedDataTypes: string[] = [];
      
      // ä¸Šä¼ å­¦ä¹ è®°å½•
      if (guestData.learningRecords && guestData.learningRecords.length > 0) {
        await this.uploadLearningRecords(guestData.learningRecords, token);
        migratedDataTypes.push('learningRecords');
      }
      
      // ä¸Šä¼ è¯æ±‡æ•°æ®
      if (guestData.vocabulary && guestData.vocabulary.length > 0) {
        await this.uploadVocabulary(guestData.vocabulary, token);
        migratedDataTypes.push('vocabulary');
      }
      
      // ä¸Šä¼ ç”¨æˆ·ç»Ÿè®¡
      if (guestData.userStats) {
        await this.uploadUserStats(guestData.userStats, token);
        migratedDataTypes.push('userStats');
      }
      
      // ä¸Šä¼ æœç´¢å†å²
      if (guestData.searchHistory && guestData.searchHistory.length > 0) {
        await this.uploadSearchHistory(guestData.searchHistory, token);
        migratedDataTypes.push('searchHistory');
      }
      
      // ä¸Šä¼ å‰§å•æ•°æ®
      if (guestData.shows && guestData.shows.length > 0) {
        await this.uploadShows(guestData.shows, token);
        migratedDataTypes.push('shows');
      }
      
      // ä¸Šä¼ ç”¨æˆ·è®¾ç½®
      if (guestData.userSettings) {
        await this.uploadUserSettings(guestData.userSettings, token);
        migratedDataTypes.push('userSettings');
      }
      
      // ä¸Šä¼ é”™è¯æ•°æ®
      if (guestData.wrongWords && guestData.wrongWords.length > 0) {
        await this.uploadWrongWords(guestData.wrongWords, token);
        migratedDataTypes.push('wrongWords');
      }
      
      // ä¸Šä¼ ç»éªŒæ•°æ®
      if (guestData.experienceGain !== undefined) {
        await this.uploadExperience(guestData.experienceGain, guestData.experienceEvents || [], token);
        migratedDataTypes.push('experience');
      }
      
      // ä¸Šä¼ è¯ä¹¦æ•°æ®
      if (guestData.wordbooks && guestData.wordbooks.length > 0) {
        await this.uploadWordbooks(guestData.wordbooks, token);
        migratedDataTypes.push('wordbooks');
      }
      
      // ä¸Šä¼ å¾½ç« æ•°æ®
      if (guestData.badges && guestData.badges.length > 0) {
        await this.uploadBadges(guestData.badges, token);
        migratedDataTypes.push('badges');
      }
      
      console.log('[GuestUpgradeService] âœ… æ•°æ®ä¸Šä¼ å®Œæˆï¼Œè¿ç§»ç±»å‹:', migratedDataTypes);
      
      return {
        success: true,
        migratedDataTypes
      };
      
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ ä¸Šä¼ æ•°æ®å¤±è´¥:', error);
      return {
        success: false,
        migratedDataTypes: [],
        error: error instanceof Error ? error.message : 'ä¸Šä¼ å¤±è´¥'
      };
    }
  }

  /**
   * ä¿å­˜æ•°æ®åˆ°æ–°ç”¨æˆ·çš„æœ¬åœ°å­˜å‚¨
   */
  private async saveDataToNewUser(guestData: GuestData, newUserId: string): Promise<void> {
    try {
      console.log('[GuestUpgradeService] ğŸ’¾ ä¿å­˜æ•°æ®åˆ°æ–°ç”¨æˆ·æœ¬åœ°å­˜å‚¨...');
      
      // ä¿å­˜å„ç§æ•°æ®ç±»å‹
      const dataToSave = {
        vocabulary: guestData.vocabulary || [],
        userStats: guestData.userStats || {},
        learningRecords: guestData.learningRecords || [],
        searchHistory: guestData.searchHistory || [],
        shows: guestData.shows || [],
        userSettings: guestData.userSettings || {},
        wrongWords: guestData.wrongWords || [],
        experienceGain: guestData.experienceGain || 0,
        experienceEvents: guestData.experienceEvents || [],
        wordbooks: guestData.wordbooks || [],
        badges: guestData.badges || []
      };
      
      // ä¿å­˜åˆ°æ–°ç”¨æˆ·çš„æœ¬åœ°å­˜å‚¨
      await AsyncStorage.setItem(`user_${newUserId}_data`, JSON.stringify(dataToSave));
      
      console.log('[GuestUpgradeService] âœ… æ•°æ®å·²ä¿å­˜åˆ°æ–°ç”¨æˆ·æœ¬åœ°å­˜å‚¨');
      
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ ä¿å­˜æ•°æ®åˆ°æ–°ç”¨æˆ·å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * æ¸…ç†æ¸¸å®¢æ•°æ®ï¼ˆå…¬å…±æ–¹æ³•ï¼‰
   */
  public async clearGuestDataPublic(): Promise<void> {
    try {
      console.log('[GuestUpgradeService] ğŸ§¹ å¼€å§‹æ¸…ç†æ¸¸å®¢æ•°æ®...');
      
      const keys = [
        'learningRecords',
        'vocabulary', 
        'user_shows',
        'userSettings',
        'userStats',
        'wrongWords',
        'experienceGain',
        'experienceEvents',
        'wordbooks',
        'badges',
        'guestId'
      ];
      
      for (const key of keys) {
        await AsyncStorage.removeItem(key);
        console.log(`[GuestUpgradeService] âœ… æ¸…ç† ${key} æ•°æ®`);
      }
      
      console.log('[GuestUpgradeService] âœ… æ¸¸å®¢æ•°æ®æ¸…ç†å®Œæˆ');
      
    } catch (error) {
      console.error('[GuestUpgradeService] âŒ æ¸…ç†æ¸¸å®¢æ•°æ®å¤±è´¥:', error);
      throw error;
    }
  }

  // å„ç§æ•°æ®ä¸Šä¼ æ–¹æ³•
  private async uploadLearningRecords(records: any[], token: string): Promise<void> {
    // å®ç°å­¦ä¹ è®°å½•ä¸Šä¼ é€»è¾‘
    console.log(`[GuestUpgradeService] ğŸ“¤ ä¸Šä¼  ${records.length} æ¡å­¦ä¹ è®°å½•`);
  }

  private async uploadVocabulary(vocabulary: any[], token: string): Promise<void> {
    // å®ç°è¯æ±‡æ•°æ®ä¸Šä¼ é€»è¾‘
    console.log(`[GuestUpgradeService] ğŸ“¤ ä¸Šä¼  ${vocabulary.length} ä¸ªè¯æ±‡`);
  }

  private async uploadUserStats(stats: any, token: string): Promise<void> {
    // å®ç°ç”¨æˆ·ç»Ÿè®¡ä¸Šä¼ é€»è¾‘
    console.log('[GuestUpgradeService] ğŸ“¤ ä¸Šä¼ ç”¨æˆ·ç»Ÿè®¡');
  }

  private async uploadSearchHistory(history: any[], token: string): Promise<void> {
    // å®ç°æœç´¢å†å²ä¸Šä¼ é€»è¾‘
    console.log(`[GuestUpgradeService] ğŸ“¤ ä¸Šä¼  ${history.length} æ¡æœç´¢å†å²`);
  }

  private async uploadShows(shows: any[], token: string): Promise<void> {
    // å®ç°å‰§å•æ•°æ®ä¸Šä¼ é€»è¾‘
    console.log(`[GuestUpgradeService] ğŸ“¤ ä¸Šä¼  ${shows.length} ä¸ªå‰§å•`);
  }

  private async uploadUserSettings(settings: any, token: string): Promise<void> {
    // å®ç°ç”¨æˆ·è®¾ç½®ä¸Šä¼ é€»è¾‘
    console.log('[GuestUpgradeService] ğŸ“¤ ä¸Šä¼ ç”¨æˆ·è®¾ç½®');
  }

  private async uploadWrongWords(wrongWords: any[], token: string): Promise<void> {
    // å®ç°é”™è¯æ•°æ®ä¸Šä¼ é€»è¾‘
    console.log(`[GuestUpgradeService] ğŸ“¤ ä¸Šä¼  ${wrongWords.length} ä¸ªé”™è¯`);
  }

  private async uploadExperience(gain: number, events: any[], token: string): Promise<void> {
    // å®ç°ç»éªŒæ•°æ®ä¸Šä¼ é€»è¾‘
    console.log(`[GuestUpgradeService] ğŸ“¤ ä¸Šä¼ ç»éªŒæ•°æ®: ${gain}, äº‹ä»¶: ${events?.length || 0}`);
  }

  private async uploadWordbooks(wordbooks: any[], token: string): Promise<void> {
    // å®ç°è¯ä¹¦æ•°æ®ä¸Šä¼ é€»è¾‘
    console.log(`[GuestUpgradeService] ğŸ“¤ ä¸Šä¼  ${wordbooks.length} ä¸ªè¯ä¹¦`);
  }

  private async uploadBadges(badges: any[], token: string): Promise<void> {
    // å®ç°å¾½ç« æ•°æ®ä¸Šä¼ é€»è¾‘
    console.log(`[GuestUpgradeService] ğŸ“¤ ä¸Šä¼  ${badges.length} ä¸ªå¾½ç« `);
  }
}

export const guestUpgradeService = GuestUpgradeService.getInstance();
