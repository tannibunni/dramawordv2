const mongoose = require('mongoose');

const MONGODB_URI = 'mongodb+srv://lt14gs:eHRN8YXnAr3tUZHd@dramaword.azbr3wj.mongodb.net/dramaword?retryWrites=true&w=majority&appName=dramaword';

// ‰øÆÂ§çUserLearningRecordÊ®°ÂûãÂ≠óÊÆµ - Â§ÑÁêÜÂµåÂ•óÁªìÊûÑ
async function fixUserLearningRecordFields() {
  try {
    console.log('üîß ‰øÆÂ§çUserLearningRecordÂ≠óÊÆµ...');
    
    const db = mongoose.connection.db;
    const collection = db.collection('userlearningrecords');
    
    // Ëé∑ÂèñÊâÄÊúâÊñáÊ°£
    const documents = await collection.find({}).toArray();
    console.log(`üìã ÊâæÂà∞ ${documents.length} ‰∏™UserLearningRecordÊñáÊ°£`);
    
    let updatedCount = 0;
    
    for (const doc of documents) {
      try {
        // Ê£ÄÊü•ÊòØÂê¶ÊúârecordsÊï∞ÁªÑ
        if (doc.records && Array.isArray(doc.records)) {
          // Êõ¥Êñ∞recordsÊï∞ÁªÑ‰∏≠ÁöÑÊØè‰∏™ËÆ∞ÂΩï
          const updatedRecords = doc.records.map(record => ({
            wordId: record.word || record.wordId || '',
            word: record.word || record.wordId || '',
            translation: record.translation || '',
            reviewCount: record.reviewCount || 0,
            correctCount: record.correctCount || 0,
            incorrectCount: record.incorrectCount || 0,
            consecutiveCorrect: record.consecutiveCorrect || 0,
            consecutiveIncorrect: record.consecutiveIncorrect || 0,
            mastery: record.mastery || 0,
            interval: record.interval || 1,
            easeFactor: record.easeFactor || 2.5,
            totalStudyTime: record.totalStudyTime || 0,
            averageResponseTime: record.averageResponseTime || 0,
            confidence: record.confidence || 0,
            nextReviewDate: record.nextReviewDate || new Date(),
            lastReviewedAt: record.lastReviewDate || new Date(),
            isLearned: record.isLearned || false,
            isMastered: record.isMastered || false,
            studyHistory: record.studyHistory || [],
            tags: record.tags || [],
            notes: record.notes || '',
            source: record.source || 'manual',
            difficulty: record.difficulty || 1
          }));
          
          // Êõ¥Êñ∞ÊñáÊ°£
          await collection.updateOne(
            { _id: doc._id },
            { 
              $set: { 
                records: updatedRecords,
                // Á°Æ‰øùÂÖ∂‰ªñÂøÖÈúÄÂ≠óÊÆµÂ≠òÂú®
                totalWords: doc.totalWords || updatedRecords.length,
                totalReviews: doc.totalReviews || 0,
                averageMastery: doc.averageMastery || 0,
                lastStudyDate: doc.lastStudyDate || new Date()
              }
            }
          );
          
          updatedCount++;
        }
      } catch (error) {
        console.error(`‚ùå Êõ¥Êñ∞ÊñáÊ°£ ${doc._id} Â§±Ë¥•:`, error.message);
      }
    }
    
    console.log(`‚úÖ Êõ¥Êñ∞‰∫Ü ${updatedCount} ‰∏™UserLearningRecordÊñáÊ°£`);
    
  } catch (error) {
    console.error('‚ùå ‰øÆÂ§çUserLearningRecordÂ§±Ë¥•:', error.message);
  }
}

// ‰øÆÂ§çSearchHistoryÊ®°ÂûãÂ≠óÊÆµ
async function fixSearchHistoryFields() {
  try {
    console.log('üîß ‰øÆÂ§çSearchHistoryÂ≠óÊÆµ...');
    
    const db = mongoose.connection.db;
    const collection = db.collection('searchhistories');
    
    // Ëé∑ÂèñÊâÄÊúâÊñáÊ°£
    const documents = await collection.find({}).toArray();
    console.log(`üìã ÊâæÂà∞ ${documents.length} ‰∏™SearchHistoryÊñáÊ°£`);
    
    let updatedCount = 0;
    
    for (const doc of documents) {
      try {
        // Êõ¥Êñ∞ÊñáÊ°£Â≠óÊÆµ
        await collection.updateOne(
          { _id: doc._id },
          {
            $set: {
              query: doc.word || doc.query || '',
              resultCount: doc.definition ? 1 : 0, // Â¶ÇÊûúÊúâdefinitionËØ¥ÊòéÊúâÁªìÊûú
              isSuccessful: true,
              timestamp: doc.timestamp || new Date()
            },
            $unset: {
              word: "",
              definition: ""
            }
          }
        );
        
        updatedCount++;
      } catch (error) {
        console.error(`‚ùå Êõ¥Êñ∞ÊñáÊ°£ ${doc._id} Â§±Ë¥•:`, error.message);
      }
    }
    
    console.log(`‚úÖ Êõ¥Êñ∞‰∫Ü ${updatedCount} ‰∏™SearchHistoryÊñáÊ°£`);
    
  } catch (error) {
    console.error('‚ùå ‰øÆÂ§çSearchHistoryÂ§±Ë¥•:', error.message);
  }
}

// ‰øÆÂ§çUserShowListÊ®°ÂûãÂ≠óÊÆµ - Â§ÑÁêÜÂµåÂ•óÁªìÊûÑ
async function fixUserShowListFields() {
  try {
    console.log('üîß ‰øÆÂ§çUserShowListÂ≠óÊÆµ...');
    
    const db = mongoose.connection.db;
    const collection = db.collection('usershowlists');
    
    // Ëé∑ÂèñÊâÄÊúâÊñáÊ°£
    const documents = await collection.find({}).toArray();
    console.log(`üìã ÊâæÂà∞ ${documents.length} ‰∏™UserShowListÊñáÊ°£`);
    
    let updatedCount = 0;
    
    for (const doc of documents) {
      try {
        // Ê£ÄÊü•ÊòØÂê¶ÊúâshowsÊï∞ÁªÑ
        if (doc.shows && Array.isArray(doc.shows)) {
          // Êõ¥Êñ∞showsÊï∞ÁªÑ‰∏≠ÁöÑÊØè‰∏™ËäÇÁõÆ
          const updatedShows = doc.shows.map(show => ({
            showId: show.id || show.showId || '',
            title: show.name || show.title || '',
            originalTitle: show.original_name || show.originalTitle || '',
            description: show.description || '',
            posterUrl: show.poster_path || show.posterUrl || '',
            language: show.language || 'en',
            genre: show.genres || show.genre || [],
            rating: show.vote_average || show.rating || 0,
            year: show.year || null,
            episodes: show.episodes || [],
            isWatching: show.status === 'watching' || show.isWatching || false,
            isCompleted: show.status === 'completed' || show.isCompleted || false,
            addedAt: show.addedAt || new Date(),
            lastWatchedAt: show.lastWatched ? new Date(show.lastWatched) : null,
            totalEpisodes: show.totalEpisodes || 0,
            watchedEpisodes: show.watchedEpisodes || 0,
            tags: show.tags || [],
            notes: show.notes || '',
            progress: show.progress || 0
          }));
          
          // Êõ¥Êñ∞ÊñáÊ°£
          await collection.updateOne(
            { _id: doc._id },
            { 
              $set: { 
                shows: updatedShows,
                updatedAt: new Date()
              }
            }
          );
          
          updatedCount++;
        }
      } catch (error) {
        console.error(`‚ùå Êõ¥Êñ∞ÊñáÊ°£ ${doc._id} Â§±Ë¥•:`, error.message);
      }
    }
    
    console.log(`‚úÖ Êõ¥Êñ∞‰∫Ü ${updatedCount} ‰∏™UserShowListÊñáÊ°£`);
    
  } catch (error) {
    console.error('‚ùå ‰øÆÂ§çUserShowListÂ§±Ë¥•:', error.message);
  }
}

// ÂàõÂª∫Áº∫Â§±ÁöÑÈõÜÂêà
async function createMissingCollections() {
  try {
    console.log('üîß ÂàõÂª∫Áº∫Â§±ÁöÑÈõÜÂêà...');
    
    const db = mongoose.connection.db;
    
    // ÂàõÂª∫BadgeÈõÜÂêà
    try {
      await db.createCollection('badges');
      console.log('‚úÖ ÂàõÂª∫‰∫ÜbadgesÈõÜÂêà');
    } catch (error) {
      if (error.code !== 48) { // 48 = ÈõÜÂêàÂ∑≤Â≠òÂú®
        console.log('‚ÑπÔ∏è  badgesÈõÜÂêàÂ∑≤Â≠òÂú®');
      }
    }
    
    // ÂàõÂª∫AchievementÈõÜÂêà
    try {
      await db.createCollection('achievements');
      console.log('‚úÖ ÂàõÂª∫‰∫ÜachievementsÈõÜÂêà');
    } catch (error) {
      if (error.code !== 48) {
        console.log('‚ÑπÔ∏è  achievementsÈõÜÂêàÂ∑≤Â≠òÂú®');
      }
    }
    
    // ÂàõÂª∫UserProgressÈõÜÂêà
    try {
      await db.createCollection('userprogresses');
      console.log('‚úÖ ÂàõÂª∫‰∫ÜuserprogressesÈõÜÂêà');
    } catch (error) {
      if (error.code !== 48) {
        console.log('‚ÑπÔ∏è  userprogressesÈõÜÂêàÂ∑≤Â≠òÂú®');
      }
    }
    
    // ÂàõÂª∫UserSettingsÈõÜÂêà
    try {
      await db.createCollection('usersettings');
      console.log('‚úÖ ÂàõÂª∫‰∫ÜusersettingsÈõÜÂêà');
    } catch (error) {
      if (error.code !== 48) {
        console.log('‚ÑπÔ∏è  usersettingsÈõÜÂêàÂ∑≤Â≠òÂú®');
      }
    }
    
  } catch (error) {
    console.error('‚ùå ÂàõÂª∫ÈõÜÂêàÂ§±Ë¥•:', error.message);
  }
}

// È™åËØÅÂ≠óÊÆµ‰øÆÂ§çÁªìÊûú
async function validateFieldFixes() {
  try {
    console.log('üîç È™åËØÅÂ≠óÊÆµ‰øÆÂ§çÁªìÊûú...');
    
    const db = mongoose.connection.db;
    
    // Ê£ÄÊü•UserLearningRecord
    const learningRecord = await db.collection('userlearningrecords').findOne();
    if (learningRecord) {
      console.log('‚úÖ UserLearningRecordÂ≠óÊÆµÈ™åËØÅ:');
      console.log('   - userId:', learningRecord.userId ? '‚úÖ' : '‚ùå');
      if (learningRecord.records && learningRecord.records.length > 0) {
        const firstRecord = learningRecord.records[0];
        console.log('   - wordId:', firstRecord.wordId ? '‚úÖ' : '‚ùå');
        console.log('   - mastery:', firstRecord.mastery !== undefined ? '‚úÖ' : '‚ùå');
        console.log('   - nextReviewDate:', firstRecord.nextReviewDate ? '‚úÖ' : '‚ùå');
      } else {
        console.log('   - Ê≤°ÊúâÂ≠¶‰π†ËÆ∞ÂΩï');
      }
    }
    
    // Ê£ÄÊü•SearchHistory
    const searchHistory = await db.collection('searchhistories').findOne();
    if (searchHistory) {
      console.log('‚úÖ SearchHistoryÂ≠óÊÆµÈ™åËØÅ:');
      console.log('   - userId:', searchHistory.userId ? '‚úÖ' : '‚ùå');
      console.log('   - query:', searchHistory.query ? '‚úÖ' : '‚ùå');
      console.log('   - timestamp:', searchHistory.timestamp ? '‚úÖ' : '‚ùå');
      console.log('   - isSuccessful:', searchHistory.isSuccessful !== undefined ? '‚úÖ' : '‚ùå');
    }
    
    // Ê£ÄÊü•UserShowList
    const showList = await db.collection('usershowlists').findOne();
    if (showList) {
      console.log('‚úÖ UserShowListÂ≠óÊÆµÈ™åËØÅ:');
      console.log('   - userId:', showList.userId ? '‚úÖ' : '‚ùå');
      if (showList.shows && showList.shows.length > 0) {
        const firstShow = showList.shows[0];
        console.log('   - showId:', firstShow.showId ? '‚úÖ' : '‚ùå');
        console.log('   - isWatching:', firstShow.isWatching !== undefined ? '‚úÖ' : '‚ùå');
        console.log('   - progress:', firstShow.progress !== undefined ? '‚úÖ' : '‚ùå');
      } else {
        console.log('   - Ê≤°ÊúâÂâßÂçïËÆ∞ÂΩï');
      }
    }
    
    // Ê£ÄÊü•Êñ∞ÈõÜÂêà
    const collections = ['badges', 'achievements', 'userprogresses', 'usersettings'];
    for (const collectionName of collections) {
      try {
        const count = await db.collection(collectionName).countDocuments();
        console.log(`‚úÖ ${collectionName}: ${count} Êù°ËÆ∞ÂΩï`);
      } catch (error) {
        console.log(`‚ùå ${collectionName}: ÈõÜÂêà‰∏çÂ≠òÂú®`);
      }
    }
    
  } catch (error) {
    console.error('‚ùå È™åËØÅÂ§±Ë¥•:', error.message);
  }
}

// ‰∏ªÂáΩÊï∞
async function fixDuolingoSyncFieldsComprehensive() {
  try {
    console.log('üîß ÂºÄÂßãÂÖ®Èù¢‰øÆÂ§çDuolingoÂêåÊ≠•Â≠óÊÆµ...');
    
    // ËøûÊé•Êï∞ÊçÆÂ∫ì
    await mongoose.connect(MONGODB_URI);
    console.log('‚úÖ Â∑≤ËøûÊé•Âà∞MongoDBÊï∞ÊçÆÂ∫ì');
    
    // ÂàõÂª∫Áº∫Â§±ÁöÑÈõÜÂêà
    await createMissingCollections();
    
    // ‰øÆÂ§çÁé∞ÊúâÊ®°ÂûãÂ≠óÊÆµ
    await fixUserLearningRecordFields();
    await fixSearchHistoryFields();
    await fixUserShowListFields();
    
    // È™åËØÅ‰øÆÂ§çÁªìÊûú
    await validateFieldFixes();
    
    console.log('\n‚úÖ DuolingoÂêåÊ≠•Â≠óÊÆµÂÖ®Èù¢‰øÆÂ§çÂÆåÊàê');
    console.log('\nüìù ÊÄªÁªì:');
    console.log('   - ÊâÄÊúâÂøÖÈúÄÁöÑÈõÜÂêàÂ∑≤ÂàõÂª∫');
    console.log('   - Â≠óÊÆµÂêçÁß∞Â∑≤‰∏éÂâçÁ´ØÂêåÊ≠•ÊúçÂä°ÂØπÈΩê');
    console.log('   - ÊîØÊåÅÂÆåÊï¥ÁöÑDuolingoÈ£éÊ†ºÊï∞ÊçÆÂêåÊ≠•');
    console.log('   - Êï∞ÊçÆÂ≠òÂÇ®Âú®Ê≠£Á°ÆÁöÑÁî®Êà∑ID‰∏ã');
    console.log('   - ÂµåÂ•óÁªìÊûÑÂ∑≤Ê≠£Á°ÆÂ§ÑÁêÜ');
    
  } catch (error) {
    console.error('‚ùå ‰øÆÂ§çÂ§±Ë¥•:', error.message);
  } finally {
    await mongoose.disconnect();
    console.log('üîå Â∑≤Êñ≠ÂºÄÊï∞ÊçÆÂ∫ìËøûÊé•');
  }
}

// ËøêË°å‰øÆÂ§ç
if (require.main === module) {
  fixDuolingoSyncFieldsComprehensive();
}

module.exports = { fixDuolingoSyncFieldsComprehensive }; 