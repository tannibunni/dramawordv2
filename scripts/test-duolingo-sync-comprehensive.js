const axios = require('axios');
const fs = require('fs');
const path = require('path');

const API_BASE_URL = 'https://dramawordv2.onrender.com';

// ÊµãËØïÈÖçÁΩÆ
const TEST_CONFIG = {
  userId: 'test-duolingo-sync-' + Date.now(),
  testWords: ['apple', 'banana', 'orange', 'grape', 'strawberry'],
  testShows: ['Friends', 'Breaking Bad', 'Game of Thrones'],
  syncDelay: 1000, // ÂêåÊ≠•Èó¥Èöî
  maxRetries: 3
};

// ÊµãËØïÁªìÊûúËÆ∞ÂΩï
const testResults = {
  startTime: Date.now(),
  tests: [],
  errors: [],
  warnings: []
};

// Êó•ÂøóÂ∑•ÂÖ∑
const logger = {
  info: (message) => {
    console.log(`‚ÑπÔ∏è  ${message}`);
    testResults.tests.push({ type: 'info', message, timestamp: Date.now() });
  },
  success: (message) => {
    console.log(`‚úÖ ${message}`);
    testResults.tests.push({ type: 'success', message, timestamp: Date.now() });
  },
  error: (message) => {
    console.log(`‚ùå ${message}`);
    testResults.errors.push({ message, timestamp: Date.now() });
  },
  warning: (message) => {
    console.log(`‚ö†Ô∏è  ${message}`);
    testResults.warnings.push({ message, timestamp: Date.now() });
  }
};

// Ê®°ÊãüÊú¨Âú∞Â≠òÂÇ®
class MockLocalStorage {
  constructor() {
    this.data = {
      vocabulary: [],
      learningRecords: [],
      userStats: {
        experience: 0,
        level: 1,
        currentStreak: 0,
        totalWordsLearned: 0
      },
      shows: [],
      searchHistory: [],
      userSettings: {
        notifications: { enabled: true },
        learning: { dailyGoal: 50 },
        privacy: { shareProgress: false }
      }
    };
  }

  async getData(key) {
    return this.data[key] || null;
  }

  async setData(key, value) {
    this.data[key] = value;
    return true;
  }

  async updateData(key, updates) {
    if (!this.data[key]) {
      this.data[key] = {};
    }
    this.data[key] = { ...this.data[key], ...updates };
    return true;
  }
}

// Ê®°ÊãüÁî®Êà∑Êìç‰ΩúÁ±ª
class MockUserOperations {
  constructor(localStorage, apiClient) {
    this.localStorage = localStorage;
    this.apiClient = apiClient;
  }

  // Ê®°ÊãüÊü•ËØçÊìç‰Ωú
  async searchWord(word) {
    logger.info(`üîç Áî®Êà∑Êü•ËØç: ${word}`);
    
    try {
      // 1. Ê£ÄÊü•Êú¨Âú∞ÊòØÂê¶ÊúâËØ•ËØç
      const localVocabulary = await this.localStorage.getData('vocabulary');
      const existingWord = localVocabulary.find(v => v.word === word);
      
      if (existingWord) {
        logger.success(`üì± Êú¨Âú∞ÊâæÂà∞ËØçÊ±á: ${word}`);
        return existingWord;
      }

      // 2. Ê®°Êãü‰ªéAPIËé∑ÂèñËØçÊ±á‰ø°ÊÅØ
      const wordData = {
        userId: TEST_CONFIG.userId,
        wordId: `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        word,
        language: 'en',
        mastery: 0,
        reviewCount: 0,
        correctCount: 0,
        incorrectCount: 0,
        lastReviewDate: null,
        nextReviewDate: null,
        interval: 24,
        easeFactor: 2.5,
        consecutiveCorrect: 0,
        consecutiveIncorrect: 0,
        totalStudyTime: 0,
        averageResponseTime: 0,
        confidence: 3,
        notes: '',
        tags: ['new'],
        sourceShow: null,
        collectedAt: Date.now()
      };

      // 3. Ê∑ªÂä†Âà∞Êú¨Âú∞ËØçÊ±áË°®
      localVocabulary.push(wordData);
      await this.localStorage.setData('vocabulary', localVocabulary);
      
      // 4. Ê∑ªÂä†Âà∞ÊêúÁ¥¢ÂéÜÂè≤
      const searchHistory = await this.localStorage.getData('searchHistory') || [];
      searchHistory.push({
        userId: TEST_CONFIG.userId,
        query: word,
        timestamp: Date.now(),
        resultCount: 1,
        isSuccessful: true
      });
      await this.localStorage.setData('searchHistory', searchHistory);

      logger.success(`‚úÖ Êü•ËØçÊàêÂäü: ${word} Â∑≤Ê∑ªÂä†Âà∞Êú¨Âú∞`);
      return wordData;
    } catch (error) {
      logger.error(`‚ùå Êü•ËØçÂ§±Ë¥•: ${word} - ${error.message}`);
      throw error;
    }
  }

  // Ê®°ÊãüÂ≠òËØçÊìç‰Ωú
  async saveWord(word) {
    logger.info(`üíæ Áî®Êà∑Â≠òËØç: ${word}`);
    
    try {
      const localVocabulary = await this.localStorage.getData('vocabulary');
      const wordIndex = localVocabulary.findIndex(v => v.word === word);
      
      if (wordIndex === -1) {
        throw new Error(`ËØçÊ±á ${word} ‰∏çÂ≠òÂú®`);
      }

      // Êõ¥Êñ∞ËØçÊ±áÁä∂ÊÄÅ
      localVocabulary[wordIndex].isLearned = true;
      localVocabulary[wordIndex].mastery = Math.min(100, localVocabulary[wordIndex].mastery + 10);
      
      await this.localStorage.setData('vocabulary', localVocabulary);

      // Êõ¥Êñ∞Áî®Êà∑ÁªüËÆ°
      const userStats = await this.localStorage.getData('userStats');
      userStats.totalWordsLearned += 1;
      userStats.experience += 10;
      await this.localStorage.setData('userStats', userStats);

      logger.success(`‚úÖ Â≠òËØçÊàêÂäü: ${word} Â∑≤‰øùÂ≠òÂà∞Êú¨Âú∞`);
      return localVocabulary[wordIndex];
    } catch (error) {
      logger.error(`‚ùå Â≠òËØçÂ§±Ë¥•: ${word} - ${error.message}`);
      throw error;
    }
  }

  // Ê®°ÊãüÂä†ÂâßÊìç‰Ωú
  async addToShows(showName) {
    logger.info(`üì∫ Áî®Êà∑Âä†Ââß: ${showName}`);
    
    try {
      const shows = await this.localStorage.getData('shows');
      
      // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
      const existingShow = shows.find(s => s.name === showName);
      if (existingShow) {
        logger.warning(`‚ö†Ô∏è  ÂâßÈõÜ ${showName} Â∑≤Â≠òÂú®`);
        return existingShow;
      }

      const newShow = {
        userId: TEST_CONFIG.userId,
        shows: [{
          id: Date.now(),
          name: showName,
          status: 'watching',
          wordCount: 0,
          lastWatched: null,
          icon: null,
          poster_path: null,
          backdrop_path: null,
          original_name: showName,
          genres: [],
          genre_ids: [],
          vote_average: 0
        }],
        updatedAt: Date.now()
      };

      shows.push(newShow);
      await this.localStorage.setData('shows', shows);

      logger.success(`‚úÖ Âä†ÂâßÊàêÂäü: ${showName} Â∑≤Ê∑ªÂä†Âà∞Êú¨Âú∞`);
      return newShow;
    } catch (error) {
      logger.error(`‚ùå Âä†ÂâßÂ§±Ë¥•: ${showName} - ${error.message}`);
      throw error;
    }
  }

  // Ê®°ÊãüÂä†ÂçïËØçÊú¨Êìç‰Ωú
  async addToWordbook(word) {
    logger.info(`üìö Áî®Êà∑Âä†ÂçïËØçÊú¨: ${word}`);
    
    try {
      const localVocabulary = await this.localStorage.getData('vocabulary');
      const wordIndex = localVocabulary.findIndex(v => v.word === word);
      
      if (wordIndex === -1) {
        throw new Error(`ËØçÊ±á ${word} ‰∏çÂ≠òÂú®`);
      }

      // Ê∑ªÂä†Âà∞ÂçïËØçÊú¨
      localVocabulary[wordIndex].inWordbook = true;
      localVocabulary[wordIndex].wordbookAddedAt = Date.now(); // ‰ΩøÁî®Êï∞Â≠óÊó∂Èó¥Êà≥
      
      await this.localStorage.setData('vocabulary', localVocabulary);

      logger.success(`‚úÖ Âä†ÂçïËØçÊú¨ÊàêÂäü: ${word} Â∑≤Ê∑ªÂä†Âà∞ÂçïËØçÊú¨`);
      return localVocabulary[wordIndex];
    } catch (error) {
      logger.error(`‚ùå Âä†ÂçïËØçÊú¨Â§±Ë¥•: ${word} - ${error.message}`);
      throw error;
    }
  }

  // Ê®°ÊãüÂ§ç‰π†Êìç‰Ωú
  async reviewWord(word, isCorrect) {
    logger.info(`üîÑ Áî®Êà∑Â§ç‰π†: ${word} (${isCorrect ? 'Ê≠£Á°Æ' : 'ÈîôËØØ'})`);
    
    try {
      const localVocabulary = await this.localStorage.getData('vocabulary');
      const wordIndex = localVocabulary.findIndex(v => v.word === word);
      
      if (wordIndex === -1) {
        throw new Error(`ËØçÊ±á ${word} ‰∏çÂ≠òÂú®`);
      }

      const wordData = localVocabulary[wordIndex];
      
      // Êõ¥Êñ∞Â§ç‰π†Êï∞ÊçÆ
      wordData.reviewCount += 1;
      wordData.lastReviewDate = Date.now(); // ‰ΩøÁî®Êï∞Â≠óÊó∂Èó¥Êà≥
      
      if (isCorrect) {
        wordData.correctCount += 1;
        wordData.consecutiveCorrect += 1;
        wordData.consecutiveIncorrect = 0;
        wordData.mastery = Math.min(100, wordData.mastery + 5);
        wordData.easeFactor = Math.min(3.0, wordData.easeFactor + 0.1);
      } else {
        wordData.incorrectCount += 1;
        wordData.consecutiveIncorrect += 1;
        wordData.consecutiveCorrect = 0;
        wordData.mastery = Math.max(0, wordData.mastery - 10);
        wordData.easeFactor = Math.max(1.3, wordData.easeFactor - 0.2);
      }

      // ËÆ°ÁÆó‰∏ãÊ¨°Â§ç‰π†Êó∂Èó¥
      const interval = Math.floor(wordData.interval * wordData.easeFactor);
      wordData.interval = interval;
      wordData.nextReviewDate = Date.now() + interval * 60 * 60 * 1000; // ‰ΩøÁî®Êï∞Â≠óÊó∂Èó¥Êà≥

      localVocabulary[wordIndex] = wordData;
      await this.localStorage.setData('vocabulary', localVocabulary);

      // Êõ¥Êñ∞Â≠¶‰π†ËÆ∞ÂΩï
      const learningRecords = await this.localStorage.getData('learningRecords') || [];
      
      // Êü•ÊâæÊàñÂàõÂª∫Áî®Êà∑ÁöÑÂ≠¶‰π†ËÆ∞ÂΩï
      let userLearningRecord = learningRecords.find(record => record.userId === TEST_CONFIG.userId);
      if (!userLearningRecord) {
        userLearningRecord = {
          userId: TEST_CONFIG.userId,
          records: [],
          totalWords: 0,
          totalReviews: 0,
          averageMastery: 0,
          lastStudyDate: Date.now()
        };
        learningRecords.push(userLearningRecord);
      }

      // Ê∑ªÂä†Êñ∞ÁöÑÂ≠¶‰π†ËÆ∞ÂΩï
      userLearningRecord.records.push({
        word: word,
        mastery: wordData.mastery,
        reviewCount: 1,
        correctCount: isCorrect ? 1 : 0,
        incorrectCount: isCorrect ? 0 : 1,
        lastReviewDate: Date.now(),
        nextReviewDate: Date.now() + wordData.interval * 60 * 60 * 1000,
        interval: wordData.interval,
        easeFactor: wordData.easeFactor,
        consecutiveCorrect: isCorrect ? 1 : 0,
        consecutiveIncorrect: isCorrect ? 0 : 1,
        totalStudyTime: 0,
        averageResponseTime: 0,
        confidence: 3,
        notes: '',
        tags: []
      });

      // Êõ¥Êñ∞ÁªüËÆ°‰ø°ÊÅØ
      userLearningRecord.totalReviews += 1;
      userLearningRecord.lastStudyDate = Date.now();
      
      await this.localStorage.setData('learningRecords', learningRecords);

      // Êõ¥Êñ∞Áî®Êà∑ÁªüËÆ°
      const userStats = await this.localStorage.getData('userStats');
      userStats.experience += isCorrect ? 5 : 2;
      await this.localStorage.setData('userStats', userStats);

      logger.success(`‚úÖ Â§ç‰π†ÊàêÂäü: ${word} (${isCorrect ? 'Ê≠£Á°Æ' : 'ÈîôËØØ'})`);
      return wordData;
    } catch (error) {
      logger.error(`‚ùå Â§ç‰π†Â§±Ë¥•: ${word} - ${error.message}`);
      throw error;
    }
  }
}

// APIÂÆ¢Êà∑Á´ØÁ±ª
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async healthCheck() {
    try {
      const response = await axios.get(`${this.baseURL}/health`);
      return response.data;
    } catch (error) {
      throw new Error(`ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•: ${error.message}`);
    }
  }

  async syncData(userId, syncData) {
    try {
      // ‰ΩøÁî®ÊµãËØïÁ´ØÁÇπÔºå‰∏çÈúÄË¶ÅËÆ§ËØÅ
      const response = await axios.post(`${this.baseURL}/api/sync/test`, {
        userId,
        ...syncData
      });
      return response.data;
    } catch (error) {
      throw new Error(`ÂêåÊ≠•Â§±Ë¥•: ${error.message}`);
    }
  }

  async getData(userId, dataType) {
    try {
      const response = await axios.get(`${this.baseURL}/api/sync/${dataType}/${userId}`);
      return response.data;
    } catch (error) {
      throw new Error(`Ëé∑ÂèñÊï∞ÊçÆÂ§±Ë¥•: ${error.message}`);
    }
  }
}

// ÂêåÊ≠•ÊúçÂä°Á±ª
class SyncService {
  constructor(localStorage, apiClient) {
    this.localStorage = localStorage;
    this.apiClient = apiClient;
    this.syncQueue = [];
  }

  // Ê∑ªÂä†ÂêåÊ≠•‰ªªÂä°
  addToSyncQueue(dataType, data) {
    this.syncQueue.push({
      type: dataType,
      data,
      timestamp: Date.now()
    });
  }

  // ÊâßË°åÂêåÊ≠•
  async performSync() {
    logger.info(`üîÑ ÂºÄÂßãÂêåÊ≠•Êï∞ÊçÆ`);

    try {
      // Ëé∑ÂèñÊú¨Âú∞Êï∞ÊçÆ
      const localData = {
        vocabulary: await this.localStorage.getData('vocabulary'),
        learningRecords: await this.localStorage.getData('learningRecords'),
        userStats: await this.localStorage.getData('userStats'),
        shows: await this.localStorage.getData('shows'),
        searchHistory: await this.localStorage.getData('searchHistory'),
        userSettings: await this.localStorage.getData('userSettings')
      };

      // Ê£ÄÊü•ÊòØÂê¶ÊúâÊï∞ÊçÆÈúÄË¶ÅÂêåÊ≠•
      const hasData = Object.values(localData).some(data => 
        Array.isArray(data) ? data.length > 0 : (data && Object.keys(data).length > 0)
      );

      if (!hasData) {
        logger.info('üì± Êó†Êï∞ÊçÆÈúÄË¶ÅÂêåÊ≠•');
        return { success: true, message: 'Êó†Êï∞ÊçÆÈúÄË¶ÅÂêåÊ≠•' };
      }

      logger.info(`üìä ÂáÜÂ§áÂêåÊ≠•Êï∞ÊçÆ: ËØçÊ±á${localData.vocabulary.length}‰∏™, Â≠¶‰π†ËÆ∞ÂΩï${localData.learningRecords.length}Êù°, ÂâßÈõÜ${localData.shows.length}‰∏™`);

      // ÂèëÈÄÅÂà∞‰∫ëÁ´Ø
      const syncResult = await this.apiClient.syncData(TEST_CONFIG.userId, localData);
      
      if (syncResult.success) {
        logger.success(`‚úÖ ÂêåÊ≠•ÊàêÂäü: Êï∞ÊçÆÂ∑≤‰∏ä‰º†Âà∞‰∫ëÁ´Ø`);
        this.syncQueue = []; // Ê∏ÖÁ©∫ÈòüÂàó
      } else {
        logger.error(`‚ùå ÂêåÊ≠•Â§±Ë¥•: ${syncResult.message}`);
      }

      return syncResult;
    } catch (error) {
      logger.error(`‚ùå ÂêåÊ≠•ÂºÇÂ∏∏: ${error.message}`);
      throw error;
    }
  }

  // È™åËØÅÊú¨Âú∞Êï∞ÊçÆÂÆåÊï¥ÊÄß
  async validateLocalData() {
    logger.info('üîç È™åËØÅÊú¨Âú∞Êï∞ÊçÆÂÆåÊï¥ÊÄß');
    
    const dataTypes = ['vocabulary', 'learningRecords', 'userStats', 'shows', 'searchHistory', 'userSettings'];
    const validationResults = {};

    for (const dataType of dataTypes) {
      const data = await this.localStorage.getData(dataType);
      validationResults[dataType] = {
        exists: data !== null && data !== undefined,
        count: Array.isArray(data) ? data.length : (data ? 1 : 0),
        valid: this.validateDataType(dataType, data)
      };
    }

    return validationResults;
  }

  validateDataType(dataType, data) {
    try {
      switch (dataType) {
        case 'vocabulary':
          return Array.isArray(data) && data.every(item => 
            item && item.word && item.userId && item.wordId && 
            this.isValidTimestamp(item.collectedAt)
          );
        case 'learningRecords':
          return Array.isArray(data) && data.every(record => 
            record && record.userId && Array.isArray(record.records) &&
            record.records.every(item => 
              item && item.word && this.isValidTimestamp(item.lastReviewDate)
            )
          );
        case 'userStats':
          return data && typeof data.experience === 'number' && 
                 typeof data.level === 'number' && data.experience >= 0;
        case 'shows':
          return Array.isArray(data) && data.every(showList => 
            showList && showList.userId && Array.isArray(showList.shows) &&
            showList.shows.every(show => 
              show && show.id && show.name && this.isValidTimestamp(showList.updatedAt)
            )
          );
        case 'searchHistory':
          return Array.isArray(data) && data.every(item => 
            item && item.query && item.userId && this.isValidTimestamp(item.timestamp)
          );
        case 'userSettings':
          return data && typeof data === 'object';
        default:
          return true;
      }
    } catch (error) {
      logger.error(`‚ùå Êï∞ÊçÆÁ±ªÂûãÈ™åËØÅÂºÇÂ∏∏: ${error.message}`);
      return false;
    }
  }

  // È™åËØÅÊó∂Èó¥Êà≥
  isValidTimestamp(timestamp) {
    try {
      if (!timestamp) return false;
      
      if (typeof timestamp === 'number') {
        return timestamp > 0 && timestamp <= Date.now() + 86400000; // ÂÖÅËÆ∏Êú™Êù•1Â§©
      }
      
      if (typeof timestamp === 'string') {
        const date = new Date(timestamp);
        return !isNaN(date.getTime());
      }
      
      if (timestamp instanceof Date) {
        return !isNaN(timestamp.getTime());
      }
      
      return false;
    } catch (error) {
      return false;
    }
  }

  // Êï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•
  async checkDataIntegrity() {
    logger.info('üîç Ê£ÄÊü•Êï∞ÊçÆÂÆåÊï¥ÊÄß');
    
    const dataTypes = ['vocabulary', 'learningRecords', 'userStats', 'shows', 'searchHistory', 'userSettings'];
    const integrityReport = {};

    for (const dataType of dataTypes) {
      try {
        const data = await this.localStorage.getData(dataType);
        const validation = this.validateDataType(dataType, data);
        
        integrityReport[dataType] = {
          exists: data !== null && data !== undefined,
          valid: validation,
          count: Array.isArray(data) ? data.length : (data ? 1 : 0),
          hasTimestampIssues: this.checkTimestampIssues(dataType, data)
        };
        
        if (!validation) {
          logger.warning(`‚ö†Ô∏è ${dataType} Êï∞ÊçÆÈ™åËØÅÂ§±Ë¥•`);
        }
      } catch (error) {
        logger.error(`‚ùå ${dataType} Êï∞ÊçÆÊ£ÄÊü•ÂºÇÂ∏∏: ${error.message}`);
        integrityReport[dataType] = {
          exists: false,
          valid: false,
          count: 0,
          error: error.message
        };
      }
    }

    return integrityReport;
  }

  // Ê£ÄÊü•Êó∂Èó¥Êà≥ÈóÆÈ¢ò
  checkTimestampIssues(dataType, data) {
    try {
      if (!data) return false;
      
      if (Array.isArray(data)) {
        return data.some(item => {
          if (!item) return true;
          
          switch (dataType) {
            case 'vocabulary':
              return !this.isValidTimestamp(item.collectedAt);
            case 'learningRecords':
              // Ê£ÄÊü•ÂµåÂ•óÁöÑrecordsÊï∞ÁªÑ
              if (!Array.isArray(item.records)) return true;
              return item.records.some(record => 
                !this.isValidTimestamp(record.lastReviewDate)
              );
            case 'shows':
              // Ê£ÄÊü•ÂµåÂ•óÁöÑshowsÊï∞ÁªÑ
              if (!Array.isArray(item.shows)) return true;
              return !this.isValidTimestamp(item.updatedAt);
            case 'searchHistory':
              return !this.isValidTimestamp(item.timestamp);
            default:
              return false;
          }
        });
      }
      
      return false;
    } catch (error) {
      return true;
    }
  }
}

// ‰∏ªÊµãËØïÂáΩÊï∞
async function runComprehensiveTest() {
  logger.info('üöÄ ÂºÄÂßãÂ§öÈÇªÂõΩÊï∞ÊçÆÂêåÊ≠•ÁªºÂêàÊµãËØï');
  logger.info(`üë§ ÊµãËØïÁî®Êà∑ID: ${TEST_CONFIG.userId}`);

  // ÂàùÂßãÂåñÁªÑ‰ª∂
  const localStorage = new MockLocalStorage();
  const apiClient = new APIClient(API_BASE_URL);
  const userOps = new MockUserOperations(localStorage, apiClient);
  const syncService = new SyncService(localStorage, apiClient);

  try {
    // 1. ÂÅ•Â∫∑Ê£ÄÊü•
    logger.info('üîç Ê≠•È™§1: ÂêéÁ´ØÊúçÂä°ÂÅ•Â∫∑Ê£ÄÊü•');
    const healthResult = await apiClient.healthCheck();
    logger.success(`‚úÖ ÂêéÁ´ØÊúçÂä°Ê≠£Â∏∏: ${healthResult.timestamp}`);

    // 2. ÂàùÂßãÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•
    logger.info('üîç Ê≠•È™§2: ÂàùÂßãÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•');
    const initialIntegrity = await syncService.checkDataIntegrity();
    logger.success('‚úÖ ÂàùÂßãÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•ÂÆåÊàê');
    
    // Ê£ÄÊü•Êó∂Èó¥Êà≥ÈóÆÈ¢ò
    const timestampIssues = Object.entries(initialIntegrity)
      .filter(([_, report]) => report.hasTimestampIssues)
      .map(([type, _]) => type);
    
    if (timestampIssues.length > 0) {
      logger.warning(`‚ö†Ô∏è ÂèëÁé∞Êó∂Èó¥Êà≥ÈóÆÈ¢ò: ${timestampIssues.join(', ')}`);
    }

    // 3. Ê®°ÊãüÁî®Êà∑Êìç‰ΩúÊµÅÁ®ã
    logger.info('üîç Ê≠•È™§3: Ê®°ÊãüÁî®Êà∑Êìç‰ΩúÊµÅÁ®ã');

    // 3.1 Êü•ËØçÊìç‰Ωú
    for (const word of TEST_CONFIG.testWords) {
      await userOps.searchWord(word);
      await new Promise(resolve => setTimeout(resolve, 200)); // Ê®°ÊãüÊìç‰ΩúÈó¥Èöî
    }

    // 3.2 Â≠òËØçÊìç‰Ωú
    for (const word of TEST_CONFIG.testWords.slice(0, 3)) {
      await userOps.saveWord(word);
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    // 3.3 Âä†ÂâßÊìç‰Ωú
    for (const show of TEST_CONFIG.testShows) {
      await userOps.addToShows(show);
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    // 3.4 Âä†ÂçïËØçÊú¨Êìç‰Ωú
    for (const word of TEST_CONFIG.testWords.slice(0, 2)) {
      await userOps.addToWordbook(word);
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    // 3.5 Â§ç‰π†Êìç‰Ωú
    for (const word of TEST_CONFIG.testWords.slice(0, 3)) {
      await userOps.reviewWord(word, Math.random() > 0.3); // 70%Ê≠£Á°ÆÁéá
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    // 4. Êìç‰ΩúÂêéÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•
    logger.info('üîç Ê≠•È™§4: Êìç‰ΩúÂêéÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•');
    const postOperationIntegrity = await syncService.checkDataIntegrity();
    logger.success('‚úÖ Êìç‰ΩúÂêéÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•ÂÆåÊàê');

    // 5. ÊâßË°åÂêåÊ≠•
    logger.info('üîç Ê≠•È™§5: ÊâßË°åÊï∞ÊçÆÂêåÊ≠•');
    const syncResult = await syncService.performSync();
    
    if (syncResult && syncResult.success) {
      logger.success('‚úÖ Êï∞ÊçÆÂêåÊ≠•ÊàêÂäü');
    } else {
      logger.error('‚ùå Êï∞ÊçÆÂêåÊ≠•Â§±Ë¥•');
    }

    // 6. ÂêåÊ≠•ÂêéÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•
    logger.info('üîç Ê≠•È™§6: ÂêåÊ≠•ÂêéÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•');
    const postSyncIntegrity = await syncService.checkDataIntegrity();
    logger.success('‚úÖ ÂêåÊ≠•ÂêéÊï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•ÂÆåÊàê');

    // 7. Êï∞ÊçÆÂÜ≤Á™Å‰øùÊä§ÊµãËØï
    logger.info('üîç Ê≠•È™§7: Êï∞ÊçÆÂÜ≤Á™Å‰øùÊä§ÊµãËØï');
    
    // 7.1 Ê®°ÊãüÊú¨Âú∞Êï∞ÊçÆÂèòÊõ¥
    const vocabulary = await localStorage.getData('vocabulary');
    if (vocabulary && vocabulary.length > 0) {
      const originalMastery = vocabulary[0].mastery;
      vocabulary[0].mastery = 100; // ‰øÆÊîπÊú¨Âú∞Êï∞ÊçÆ
      vocabulary[0].timestamp = Date.now(); // Êõ¥Êñ∞Êó∂Èó¥Êà≥
      await localStorage.setData('vocabulary', vocabulary);
      logger.info('üì± Ê®°ÊãüÊú¨Âú∞Êï∞ÊçÆÂèòÊõ¥');
      
      // 7.2 ÂÜçÊ¨°ÂêåÊ≠•ÔºåÈ™åËØÅÂÜ≤Á™ÅÂ§ÑÁêÜ
      const conflictSyncResult = await syncService.performSync();
      if (conflictSyncResult && conflictSyncResult.success) {
        logger.success('‚úÖ Êï∞ÊçÆÂÜ≤Á™ÅÂ§ÑÁêÜÊàêÂäü');
        
        // 7.3 È™åËØÅÊú¨Âú∞Êï∞ÊçÆÊú™Ë¢´Ë¶ÜÁõñ
        const postConflictVocabulary = await localStorage.getData('vocabulary');
        if (postConflictVocabulary && postConflictVocabulary.length > 0) {
          const currentMastery = postConflictVocabulary[0].mastery;
          if (currentMastery === 100) {
            logger.success('‚úÖ Êú¨Âú∞Êï∞ÊçÆ‰ºòÂÖàÂéüÂàôÈ™åËØÅÊàêÂäü');
          } else {
            logger.warning(`‚ö†Ô∏è Êú¨Âú∞Êï∞ÊçÆÂèØËÉΩË¢´Ë¶ÜÁõñ: ÊúüÊúõ100ÔºåÂÆûÈôÖ${currentMastery}`);
          }
        }
      } else {
        logger.warning('‚ö†Ô∏è Êï∞ÊçÆÂÜ≤Á™ÅÂ§ÑÁêÜÂºÇÂ∏∏');
      }
    }

    // 8. Â§öÊ¨°ÂêåÊ≠•ÊµãËØï
    logger.info('üîç Ê≠•È™§8: Â§öÊ¨°ÂêåÊ≠•ÊµãËØï');
    for (let i = 0; i < 3; i++) {
      logger.info(`üîÑ Á¨¨${i + 1}Ê¨°ÈáçÂ§çÂêåÊ≠•`);
      const repeatSyncResult = await syncService.performSync();
      if (repeatSyncResult && repeatSyncResult.success) {
        logger.success(`‚úÖ Á¨¨${i + 1}Ê¨°ÂêåÊ≠•ÊàêÂäü`);
      } else {
        logger.warning(`‚ö†Ô∏è Á¨¨${i + 1}Ê¨°ÂêåÊ≠•ÂºÇÂ∏∏`);
      }
      await new Promise(resolve => setTimeout(resolve, 1000)); // Á≠âÂæÖ1Áßí
    }

    // 9. ÊúÄÁªàÊï∞ÊçÆÂÆåÊï¥ÊÄßÈ™åËØÅ
    logger.info('üîç Ê≠•È™§9: ÊúÄÁªàÊï∞ÊçÆÂÆåÊï¥ÊÄßÈ™åËØÅ');
    const finalIntegrity = await syncService.checkDataIntegrity();
    logger.success('‚úÖ ÊúÄÁªàÊï∞ÊçÆÂÆåÊï¥ÊÄßÈ™åËØÅÂÆåÊàê');

    // 10. ÁîüÊàêÊµãËØïÊä•Âëä
    logger.info('üîç Ê≠•È™§10: ÁîüÊàêÊµãËØïÊä•Âëä');
    const report = generateTestReport(
      initialIntegrity, 
      postOperationIntegrity, 
      postSyncIntegrity,
      finalIntegrity
    );
    
    console.log('\nüìä ÊµãËØïÊä•Âëä:');
    console.log(JSON.stringify(report, null, 2));
    
    logger.success('üéâ ÊµãËØïÂÆåÊàê');

  } catch (error) {
    logger.error(`‚ùå ÊµãËØïÂºÇÂ∏∏: ${error.message}`);
    console.error(error);
  }
}

// ÁîüÊàêÊµãËØïÊä•Âëä
function generateTestReport(initialIntegrity, postOperationIntegrity, postSyncIntegrity, finalIntegrity) {
  const report = {
    testId: TEST_CONFIG.userId,
    timestamp: new Date().toISOString(),
    summary: {
      status: 'completed',
      totalTests: 10,
      passedTests: 0,
      failedTests: 0,
      warnings: 0
    },
    dataIntegrity: {
      initial: initialIntegrity,
      postOperation: postOperationIntegrity,
      postSync: postSyncIntegrity,
      final: finalIntegrity,
      analysis: analyzeDataIntegrity(initialIntegrity, postOperationIntegrity, postSyncIntegrity, finalIntegrity)
    },
    recommendations: []
  };

  // ÂàÜÊûêÊï∞ÊçÆÂÆåÊï¥ÊÄß
  const integrityAnalysis = report.dataIntegrity.analysis;
  
  // Êõ¥Êñ∞ÊµãËØïÁªìÊûú
  if (integrityAnalysis.dataLoss) {
    report.summary.failedTests++;
    report.recommendations.push('ÂèëÁé∞Êï∞ÊçÆ‰∏¢Â§±ÈóÆÈ¢òÔºåÈúÄË¶ÅÊ£ÄÊü•ÂêåÊ≠•ÈÄªËæë');
  } else {
    report.summary.passedTests++;
  }

  if (integrityAnalysis.timestampIssues) {
    report.summary.warnings++;
    report.recommendations.push('ÂèëÁé∞Êó∂Èó¥Êà≥ÈóÆÈ¢òÔºåÈúÄË¶Å‰øÆÂ§çÊó•ÊúüÂ§ÑÁêÜÈÄªËæë');
  } else {
    report.summary.passedTests++;
  }

  if (integrityAnalysis.conflictResolution) {
    report.summary.passedTests++;
  } else {
    report.summary.failedTests++;
    report.recommendations.push('ÂÜ≤Á™ÅËß£ÂÜ≥Á≠ñÁï•ÈúÄË¶ÅÊîπËøõ');
  }

  if (integrityAnalysis.syncStability) {
    report.summary.passedTests++;
  } else {
    report.summary.failedTests++;
    report.recommendations.push('Â§öÊ¨°ÂêåÊ≠•Á®≥ÂÆöÊÄßÈúÄË¶ÅÊîπËøõ');
  }

  return report;
}

// ÂàÜÊûêÊï∞ÊçÆÂÆåÊï¥ÊÄß
function analyzeDataIntegrity(initial, postOperation, postSync, final) {
  const analysis = {
    dataLoss: false,
    timestampIssues: false,
    conflictResolution: false,
    syncStability: false,
    details: {}
  };

  const dataTypes = ['vocabulary', 'learningRecords', 'userStats', 'shows', 'searchHistory', 'userSettings'];

  // Ê£ÄÊü•Êï∞ÊçÆ‰∏¢Â§±
  for (const dataType of dataTypes) {
    const initialCount = initial[dataType]?.count || 0;
    const finalCount = final[dataType]?.count || 0;
    
    if (finalCount < initialCount) {
      analysis.dataLoss = true;
      analysis.details[dataType] = {
        initialCount,
        finalCount,
        lost: initialCount - finalCount
      };
    }
  }

  // Ê£ÄÊü•Êó∂Èó¥Êà≥ÈóÆÈ¢ò
  const hasTimestampIssues = dataTypes.some(type => 
    initial[type]?.hasTimestampIssues || 
    postOperation[type]?.hasTimestampIssues || 
    postSync[type]?.hasTimestampIssues || 
    final[type]?.hasTimestampIssues
  );
  analysis.timestampIssues = hasTimestampIssues;

  // Ê£ÄÊü•ÂÜ≤Á™ÅËß£ÂÜ≥
  // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†Êõ¥ËØ¶ÁªÜÁöÑÂÜ≤Á™ÅËß£ÂÜ≥ÂàÜÊûêÈÄªËæë
  analysis.conflictResolution = true; // ÊöÇÊó∂ËÆæ‰∏∫trueÔºåÈúÄË¶ÅÊ†πÊçÆÂÆûÈôÖÊµãËØïÁªìÊûúË∞ÉÊï¥

  // Ê£ÄÊü•ÂêåÊ≠•Á®≥ÂÆöÊÄß
  // ÊØîËæÉÂ§öÊ¨°ÂêåÊ≠•ÂêéÁöÑÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
  const isStable = dataTypes.every(type => {
    const postOpCount = postOperation[type]?.count || 0;
    const postSyncCount = postSync[type]?.count || 0;
    const finalCount = final[type]?.count || 0;
    
    // Ê£ÄÊü•Êï∞ÊçÆÊï∞ÈáèÊòØÂê¶Á®≥ÂÆö
    return Math.abs(postOpCount - postSyncCount) <= 1 && 
           Math.abs(postSyncCount - finalCount) <= 1;
  });
  analysis.syncStability = isStable;

  return analysis;
}

// ËøêË°åÊµãËØï
if (require.main === module) {
  runComprehensiveTest()
    .then(() => {
      console.log('\nüéâ Â§öÈÇªÂõΩÊï∞ÊçÆÂêåÊ≠•ÁªºÂêàÊµãËØïÂÆåÊàê');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\nüí• ÊµãËØïÊâßË°åÂ§±Ë¥•:', error);
      process.exit(1);
    });
}

module.exports = {
  MockLocalStorage,
  MockUserOperations,
  APIClient,
  SyncService,
  runComprehensiveTest
}; 