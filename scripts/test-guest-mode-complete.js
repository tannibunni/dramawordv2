// 模拟 AsyncStorage 的简单实现
class MockAsyncStorage {
  constructor() {
    this.storage = new Map();
  }

  async setItem(key, value) {
    this.storage.set(key, value);
  }

  async getItem(key) {
    return this.storage.get(key) || null;
  }

  async removeItem(key) {
    this.storage.delete(key);
  }

  async multiRemove(keys) {
    keys.forEach(key => this.storage.delete(key));
  }

  async getAllKeys() {
    return Array.from(this.storage.keys());
  }

  async clear() {
    this.storage.clear();
  }
}

// 使用模拟的 AsyncStorage
const AsyncStorage = new MockAsyncStorage();

class GuestModeTester {
  constructor() {
    this.testResults = [];
    this.guestId = null;
  }

  async runAllTests() {
    console.log('🚀 开始游客模式完整测试\n');

    try {
      // 测试1: 游客模式检测
      await this.testGuestModeDetection();
      
      // 测试2: 数据隔离
      await this.testDataIsolation();
      
      // 测试3: 本地存储
      await this.testLocalStorage();
      
      // 测试4: 数据统计
      await this.testDataStats();
      
      // 测试5: 数据完整性
      await this.testDataIntegrity();
      
      // 测试6: 备份恢复
      await this.testBackupRestore();
      
      // 测试7: 重置功能
      await this.testResetFunctionality();
      
      // 生成测试报告
      this.generateTestReport();
      
    } catch (error) {
      console.error('❌ 测试过程中发生错误:', error);
    }
  }

  async testGuestModeDetection() {
    console.log('📋 测试1: 游客模式检测');
    
    try {
      // 模拟游客用户数据
      const guestUserData = {
        id: 'guest_test_123',
        nickname: '测试游客',
        loginType: 'guest',
        token: null,
        isAutoGenerated: true,
        createdAt: Date.now(),
        localDataVersion: 1
      };

      await AsyncStorage.setItem('userData', JSON.stringify(guestUserData));
      
      // 检查是否为游客模式
      const userData = await AsyncStorage.getItem('userData');
      const parsed = JSON.parse(userData);
      const isGuest = parsed.loginType === 'guest' && !parsed.token;
      
      this.testResults.push({
        test: '游客模式检测',
        passed: isGuest,
        details: `loginType: ${parsed.loginType}, hasToken: ${!!parsed.token}`
      });
      
      console.log(`✅ 游客模式检测: ${isGuest ? '通过' : '失败'}`);
      this.guestId = parsed.id;
      
    } catch (error) {
      this.testResults.push({
        test: '游客模式检测',
        passed: false,
        details: error.message
      });
      console.log('❌ 游客模式检测失败:', error.message);
    }
  }

  async testDataIsolation() {
    console.log('\n📋 测试2: 数据隔离');
    
    try {
      // 创建两个不同的游客ID
      const guestId1 = 'guest_test_123';
      const guestId2 = 'guest_test_456';
      
      // 为游客1存储数据
      const data1 = { vocabulary: ['word1', 'word2'], progress: 50 };
      await AsyncStorage.setItem(`guest_${guestId1}_vocabulary`, JSON.stringify({
        data: data1,
        timestamp: Date.now(),
        guestId: guestId1,
        version: 1
      }));
      
      // 为游客2存储数据
      const data2 = { vocabulary: ['word3', 'word4'], progress: 75 };
      await AsyncStorage.setItem(`guest_${guestId2}_vocabulary`, JSON.stringify({
        data: data2,
        timestamp: Date.now(),
        guestId: guestId2,
        version: 1
      }));
      
      // 验证数据隔离
      const stored1 = await AsyncStorage.getItem(`guest_${guestId1}_vocabulary`);
      const stored2 = await AsyncStorage.getItem(`guest_${guestId2}_vocabulary`);
      
      const parsed1 = JSON.parse(stored1);
      const parsed2 = JSON.parse(stored2);
      
      const isIsolated = parsed1.data.vocabulary.length === 2 && 
                        parsed2.data.vocabulary.length === 2 &&
                        parsed1.data.vocabulary[0] !== parsed2.data.vocabulary[0];
      
      this.testResults.push({
        test: '数据隔离',
        passed: isIsolated,
        details: `游客1数据: ${parsed1.data.vocabulary.join(', ')}, 游客2数据: ${parsed2.data.vocabulary.join(', ')}`
      });
      
      console.log(`✅ 数据隔离: ${isIsolated ? '通过' : '失败'}`);
      
    } catch (error) {
      this.testResults.push({
        test: '数据隔离',
        passed: false,
        details: error.message
      });
      console.log('❌ 数据隔离测试失败:', error.message);
    }
  }

  async testLocalStorage() {
    console.log('\n📋 测试3: 本地存储');
    
    try {
      const testData = {
        vocabulary: ['test_word_1', 'test_word_2'],
        learningRecords: [
          { word: 'test_word_1', timestamp: Date.now(), correct: true },
          { word: 'test_word_2', timestamp: Date.now(), correct: false }
        ],
        userStats: {
          totalWords: 2,
          correctAnswers: 1,
          incorrectAnswers: 1,
          accuracy: 0.5
        }
      };
      
      // 存储测试数据
      for (const [key, value] of Object.entries(testData)) {
        await AsyncStorage.setItem(`guest_${this.guestId}_${key}`, JSON.stringify({
          data: value,
          timestamp: Date.now(),
          guestId: this.guestId,
          version: 1
        }));
      }
      
      // 验证数据存储
      let allStored = true;
      for (const key of Object.keys(testData)) {
        const stored = await AsyncStorage.getItem(`guest_${this.guestId}_${key}`);
        if (!stored) {
          allStored = false;
          break;
        }
      }
      
      this.testResults.push({
        test: '本地存储',
        passed: allStored,
        details: `存储了 ${Object.keys(testData).length} 种数据类型`
      });
      
      console.log(`✅ 本地存储: ${allStored ? '通过' : '失败'}`);
      
    } catch (error) {
      this.testResults.push({
        test: '本地存储',
        passed: false,
        details: error.message
      });
      console.log('❌ 本地存储测试失败:', error.message);
    }
  }

  async testDataStats() {
    console.log('\n📋 测试4: 数据统计');
    
    try {
      // 获取所有游客相关的键
      const allKeys = await AsyncStorage.getAllKeys();
      const guestKeys = allKeys.filter(key => key.startsWith(`guest_${this.guestId}_`));
      
      let totalSize = 0;
      const dataTypes = new Set();
      
      for (const key of guestKeys) {
        const value = await AsyncStorage.getItem(key);
        if (value) {
          totalSize += value.length;
          const dataType = key.replace(`guest_${this.guestId}_`, '');
          dataTypes.add(dataType);
        }
      }
      
      const hasStats = guestKeys.length > 0 && totalSize > 0 && dataTypes.size > 0;
      
      this.testResults.push({
        test: '数据统计',
        passed: hasStats,
        details: `数据项: ${guestKeys.length}, 大小: ${totalSize}字节, 类型: ${Array.from(dataTypes).join(', ')}`
      });
      
      console.log(`✅ 数据统计: ${hasStats ? '通过' : '失败'}`);
      
    } catch (error) {
      this.testResults.push({
        test: '数据统计',
        passed: false,
        details: error.message
      });
      console.log('❌ 数据统计测试失败:', error.message);
    }
  }

  async testDataIntegrity() {
    console.log('\n📋 测试5: 数据完整性');
    
    try {
      const criticalKeys = ['vocabulary', 'userStats', 'learningRecords'];
      let allValid = true;
      const issues = [];
      
      for (const key of criticalKeys) {
        const stored = await AsyncStorage.getItem(`guest_${this.guestId}_${key}`);
        if (!stored) {
          allValid = false;
          issues.push(`缺少关键数据: ${key}`);
        } else {
          try {
            const parsed = JSON.parse(stored);
            if (!parsed.data || !parsed.guestId || !parsed.version) {
              allValid = false;
              issues.push(`数据格式错误: ${key}`);
            }
          } catch (error) {
            allValid = false;
            issues.push(`数据解析失败: ${key}`);
          }
        }
      }
      
      this.testResults.push({
        test: '数据完整性',
        passed: allValid,
        details: issues.length > 0 ? issues.join(', ') : '所有关键数据完整'
      });
      
      console.log(`✅ 数据完整性: ${allValid ? '通过' : '失败'}`);
      
    } catch (error) {
      this.testResults.push({
        test: '数据完整性',
        passed: false,
        details: error.message
      });
      console.log('❌ 数据完整性测试失败:', error.message);
    }
  }

  async testBackupRestore() {
    console.log('\n📋 测试6: 备份恢复');
    
    try {
      // 创建备份数据
      const backupData = {
        timestamp: Date.now(),
        guestId: this.guestId,
        data: {
          vocabulary: ['backup_word_1', 'backup_word_2'],
          userStats: { totalWords: 2, accuracy: 0.8 }
        }
      };
      
      const backupKey = `guest_backup_${this.guestId}_${backupData.timestamp}`;
      await AsyncStorage.setItem(backupKey, JSON.stringify(backupData));
      
      // 验证备份
      const storedBackup = await AsyncStorage.getItem(backupKey);
      const parsedBackup = JSON.parse(storedBackup);
      
      const backupValid = parsedBackup.guestId === this.guestId && 
                         parsedBackup.data.vocabulary.length === 2;
      
      this.testResults.push({
        test: '备份恢复',
        passed: backupValid,
        details: `备份大小: ${storedBackup.length}字节, 包含 ${Object.keys(parsedBackup.data).length} 种数据类型`
      });
      
      console.log(`✅ 备份恢复: ${backupValid ? '通过' : '失败'}`);
      
    } catch (error) {
      this.testResults.push({
        test: '备份恢复',
        passed: false,
        details: error.message
      });
      console.log('❌ 备份恢复测试失败:', error.message);
    }
  }

  async testResetFunctionality() {
    console.log('\n📋 测试7: 重置功能');
    
    try {
      // 记录重置前的数据项数量
      const allKeysBefore = await AsyncStorage.getAllKeys();
      const guestKeysBefore = allKeysBefore.filter(key => key.startsWith(`guest_${this.guestId}_`));
      
      // 模拟重置（清除游客数据）
      const allKeys = await AsyncStorage.getAllKeys();
      const guestKeys = allKeys.filter(key => key.startsWith(`guest_${this.guestId}_`));
      
      if (guestKeys.length > 0) {
        await AsyncStorage.multiRemove(guestKeys);
      }
      
      // 验证重置结果
      const allKeysAfter = await AsyncStorage.getAllKeys();
      const guestKeysAfter = allKeysAfter.filter(key => key.startsWith(`guest_${this.guestId}_`));
      
      const resetSuccessful = guestKeysAfter.length === 0 && guestKeysBefore.length > 0;
      
      this.testResults.push({
        test: '重置功能',
        passed: resetSuccessful,
        details: `重置前: ${guestKeysBefore.length}项, 重置后: ${guestKeysAfter.length}项`
      });
      
      console.log(`✅ 重置功能: ${resetSuccessful ? '通过' : '失败'}`);
      
    } catch (error) {
      this.testResults.push({
        test: '重置功能',
        passed: false,
        details: error.message
      });
      console.log('❌ 重置功能测试失败:', error.message);
    }
  }

  generateTestReport() {
    console.log('\n📊 游客模式测试报告');
    console.log('='.repeat(50));
    
    const passedTests = this.testResults.filter(result => result.passed);
    const failedTests = this.testResults.filter(result => !result.passed);
    
    console.log(`总测试数: ${this.testResults.length}`);
    console.log(`通过: ${passedTests.length}`);
    console.log(`失败: ${failedTests.length}`);
    console.log(`成功率: ${((passedTests.length / this.testResults.length) * 100).toFixed(1)}%`);
    
    console.log('\n📋 详细结果:');
    this.testResults.forEach((result, index) => {
      const status = result.passed ? '✅' : '❌';
      console.log(`${index + 1}. ${status} ${result.test}: ${result.details}`);
    });
    
    if (failedTests.length > 0) {
      console.log('\n⚠️ 失败测试详情:');
      failedTests.forEach(test => {
        console.log(`- ${test.test}: ${test.details}`);
      });
    }
    
    if (passedTests.length === this.testResults.length) {
      console.log('\n🎉 所有测试通过！游客模式功能完全正常');
    } else {
      console.log('\n⚠️ 部分测试失败，需要检查相关功能');
    }
  }
}

// 运行测试
async function runTests() {
  const tester = new GuestModeTester();
  await tester.runAllTests();
}

// 如果直接运行此脚本
if (require.main === module) {
  runTests().catch(console.error);
}

module.exports = GuestModeTester; 