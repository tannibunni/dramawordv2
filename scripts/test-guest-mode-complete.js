// æ¨¡æ‹Ÿ AsyncStorage çš„ç®€å•å®ç°
class MockAsyncStorage {
  constructor() {
    this.storage = new Map();
  }

  async setItem(key, value) {
    this.storage.set(key, value);
  }

  async getItem(key) {
    return this.storage.get(key) || null;
  }

  async removeItem(key) {
    this.storage.delete(key);
  }

  async multiRemove(keys) {
    keys.forEach(key => this.storage.delete(key));
  }

  async getAllKeys() {
    return Array.from(this.storage.keys());
  }

  async clear() {
    this.storage.clear();
  }
}

// ä½¿ç”¨æ¨¡æ‹Ÿçš„ AsyncStorage
const AsyncStorage = new MockAsyncStorage();

class GuestModeTester {
  constructor() {
    this.testResults = [];
    this.guestId = null;
  }

  async runAllTests() {
    console.log('ğŸš€ å¼€å§‹æ¸¸å®¢æ¨¡å¼å®Œæ•´æµ‹è¯•\n');

    try {
      // æµ‹è¯•1: æ¸¸å®¢æ¨¡å¼æ£€æµ‹
      await this.testGuestModeDetection();
      
      // æµ‹è¯•2: æ•°æ®éš”ç¦»
      await this.testDataIsolation();
      
      // æµ‹è¯•3: æœ¬åœ°å­˜å‚¨
      await this.testLocalStorage();
      
      // æµ‹è¯•4: æ•°æ®ç»Ÿè®¡
      await this.testDataStats();
      
      // æµ‹è¯•5: æ•°æ®å®Œæ•´æ€§
      await this.testDataIntegrity();
      
      // æµ‹è¯•6: å¤‡ä»½æ¢å¤
      await this.testBackupRestore();
      
      // æµ‹è¯•7: é‡ç½®åŠŸèƒ½
      await this.testResetFunctionality();
      
      // ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
      this.generateTestReport();
      
    } catch (error) {
      console.error('âŒ æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
    }
  }

  async testGuestModeDetection() {
    console.log('ğŸ“‹ æµ‹è¯•1: æ¸¸å®¢æ¨¡å¼æ£€æµ‹');
    
    try {
      // æ¨¡æ‹Ÿæ¸¸å®¢ç”¨æˆ·æ•°æ®
      const guestUserData = {
        id: 'guest_test_123',
        nickname: 'æµ‹è¯•æ¸¸å®¢',
        loginType: 'guest',
        token: null,
        isAutoGenerated: true,
        createdAt: Date.now(),
        localDataVersion: 1
      };

      await AsyncStorage.setItem('userData', JSON.stringify(guestUserData));
      
      // æ£€æŸ¥æ˜¯å¦ä¸ºæ¸¸å®¢æ¨¡å¼
      const userData = await AsyncStorage.getItem('userData');
      const parsed = JSON.parse(userData);
      const isGuest = parsed.loginType === 'guest' && !parsed.token;
      
      this.testResults.push({
        test: 'æ¸¸å®¢æ¨¡å¼æ£€æµ‹',
        passed: isGuest,
        details: `loginType: ${parsed.loginType}, hasToken: ${!!parsed.token}`
      });
      
      console.log(`âœ… æ¸¸å®¢æ¨¡å¼æ£€æµ‹: ${isGuest ? 'é€šè¿‡' : 'å¤±è´¥'}`);
      this.guestId = parsed.id;
      
    } catch (error) {
      this.testResults.push({
        test: 'æ¸¸å®¢æ¨¡å¼æ£€æµ‹',
        passed: false,
        details: error.message
      });
      console.log('âŒ æ¸¸å®¢æ¨¡å¼æ£€æµ‹å¤±è´¥:', error.message);
    }
  }

  async testDataIsolation() {
    console.log('\nğŸ“‹ æµ‹è¯•2: æ•°æ®éš”ç¦»');
    
    try {
      // åˆ›å»ºä¸¤ä¸ªä¸åŒçš„æ¸¸å®¢ID
      const guestId1 = 'guest_test_123';
      const guestId2 = 'guest_test_456';
      
      // ä¸ºæ¸¸å®¢1å­˜å‚¨æ•°æ®
      const data1 = { vocabulary: ['word1', 'word2'], progress: 50 };
      await AsyncStorage.setItem(`guest_${guestId1}_vocabulary`, JSON.stringify({
        data: data1,
        timestamp: Date.now(),
        guestId: guestId1,
        version: 1
      }));
      
      // ä¸ºæ¸¸å®¢2å­˜å‚¨æ•°æ®
      const data2 = { vocabulary: ['word3', 'word4'], progress: 75 };
      await AsyncStorage.setItem(`guest_${guestId2}_vocabulary`, JSON.stringify({
        data: data2,
        timestamp: Date.now(),
        guestId: guestId2,
        version: 1
      }));
      
      // éªŒè¯æ•°æ®éš”ç¦»
      const stored1 = await AsyncStorage.getItem(`guest_${guestId1}_vocabulary`);
      const stored2 = await AsyncStorage.getItem(`guest_${guestId2}_vocabulary`);
      
      const parsed1 = JSON.parse(stored1);
      const parsed2 = JSON.parse(stored2);
      
      const isIsolated = parsed1.data.vocabulary.length === 2 && 
                        parsed2.data.vocabulary.length === 2 &&
                        parsed1.data.vocabulary[0] !== parsed2.data.vocabulary[0];
      
      this.testResults.push({
        test: 'æ•°æ®éš”ç¦»',
        passed: isIsolated,
        details: `æ¸¸å®¢1æ•°æ®: ${parsed1.data.vocabulary.join(', ')}, æ¸¸å®¢2æ•°æ®: ${parsed2.data.vocabulary.join(', ')}`
      });
      
      console.log(`âœ… æ•°æ®éš”ç¦»: ${isIsolated ? 'é€šè¿‡' : 'å¤±è´¥'}`);
      
    } catch (error) {
      this.testResults.push({
        test: 'æ•°æ®éš”ç¦»',
        passed: false,
        details: error.message
      });
      console.log('âŒ æ•°æ®éš”ç¦»æµ‹è¯•å¤±è´¥:', error.message);
    }
  }

  async testLocalStorage() {
    console.log('\nğŸ“‹ æµ‹è¯•3: æœ¬åœ°å­˜å‚¨');
    
    try {
      const testData = {
        vocabulary: ['test_word_1', 'test_word_2'],
        learningRecords: [
          { word: 'test_word_1', timestamp: Date.now(), correct: true },
          { word: 'test_word_2', timestamp: Date.now(), correct: false }
        ],
        userStats: {
          totalWords: 2,
          correctAnswers: 1,
          incorrectAnswers: 1,
          accuracy: 0.5
        }
      };
      
      // å­˜å‚¨æµ‹è¯•æ•°æ®
      for (const [key, value] of Object.entries(testData)) {
        await AsyncStorage.setItem(`guest_${this.guestId}_${key}`, JSON.stringify({
          data: value,
          timestamp: Date.now(),
          guestId: this.guestId,
          version: 1
        }));
      }
      
      // éªŒè¯æ•°æ®å­˜å‚¨
      let allStored = true;
      for (const key of Object.keys(testData)) {
        const stored = await AsyncStorage.getItem(`guest_${this.guestId}_${key}`);
        if (!stored) {
          allStored = false;
          break;
        }
      }
      
      this.testResults.push({
        test: 'æœ¬åœ°å­˜å‚¨',
        passed: allStored,
        details: `å­˜å‚¨äº† ${Object.keys(testData).length} ç§æ•°æ®ç±»å‹`
      });
      
      console.log(`âœ… æœ¬åœ°å­˜å‚¨: ${allStored ? 'é€šè¿‡' : 'å¤±è´¥'}`);
      
    } catch (error) {
      this.testResults.push({
        test: 'æœ¬åœ°å­˜å‚¨',
        passed: false,
        details: error.message
      });
      console.log('âŒ æœ¬åœ°å­˜å‚¨æµ‹è¯•å¤±è´¥:', error.message);
    }
  }

  async testDataStats() {
    console.log('\nğŸ“‹ æµ‹è¯•4: æ•°æ®ç»Ÿè®¡');
    
    try {
      // è·å–æ‰€æœ‰æ¸¸å®¢ç›¸å…³çš„é”®
      const allKeys = await AsyncStorage.getAllKeys();
      const guestKeys = allKeys.filter(key => key.startsWith(`guest_${this.guestId}_`));
      
      let totalSize = 0;
      const dataTypes = new Set();
      
      for (const key of guestKeys) {
        const value = await AsyncStorage.getItem(key);
        if (value) {
          totalSize += value.length;
          const dataType = key.replace(`guest_${this.guestId}_`, '');
          dataTypes.add(dataType);
        }
      }
      
      const hasStats = guestKeys.length > 0 && totalSize > 0 && dataTypes.size > 0;
      
      this.testResults.push({
        test: 'æ•°æ®ç»Ÿè®¡',
        passed: hasStats,
        details: `æ•°æ®é¡¹: ${guestKeys.length}, å¤§å°: ${totalSize}å­—èŠ‚, ç±»å‹: ${Array.from(dataTypes).join(', ')}`
      });
      
      console.log(`âœ… æ•°æ®ç»Ÿè®¡: ${hasStats ? 'é€šè¿‡' : 'å¤±è´¥'}`);
      
    } catch (error) {
      this.testResults.push({
        test: 'æ•°æ®ç»Ÿè®¡',
        passed: false,
        details: error.message
      });
      console.log('âŒ æ•°æ®ç»Ÿè®¡æµ‹è¯•å¤±è´¥:', error.message);
    }
  }

  async testDataIntegrity() {
    console.log('\nğŸ“‹ æµ‹è¯•5: æ•°æ®å®Œæ•´æ€§');
    
    try {
      const criticalKeys = ['vocabulary', 'userStats', 'learningRecords'];
      let allValid = true;
      const issues = [];
      
      for (const key of criticalKeys) {
        const stored = await AsyncStorage.getItem(`guest_${this.guestId}_${key}`);
        if (!stored) {
          allValid = false;
          issues.push(`ç¼ºå°‘å…³é”®æ•°æ®: ${key}`);
        } else {
          try {
            const parsed = JSON.parse(stored);
            if (!parsed.data || !parsed.guestId || !parsed.version) {
              allValid = false;
              issues.push(`æ•°æ®æ ¼å¼é”™è¯¯: ${key}`);
            }
          } catch (error) {
            allValid = false;
            issues.push(`æ•°æ®è§£æå¤±è´¥: ${key}`);
          }
        }
      }
      
      this.testResults.push({
        test: 'æ•°æ®å®Œæ•´æ€§',
        passed: allValid,
        details: issues.length > 0 ? issues.join(', ') : 'æ‰€æœ‰å…³é”®æ•°æ®å®Œæ•´'
      });
      
      console.log(`âœ… æ•°æ®å®Œæ•´æ€§: ${allValid ? 'é€šè¿‡' : 'å¤±è´¥'}`);
      
    } catch (error) {
      this.testResults.push({
        test: 'æ•°æ®å®Œæ•´æ€§',
        passed: false,
        details: error.message
      });
      console.log('âŒ æ•°æ®å®Œæ•´æ€§æµ‹è¯•å¤±è´¥:', error.message);
    }
  }

  async testBackupRestore() {
    console.log('\nğŸ“‹ æµ‹è¯•6: å¤‡ä»½æ¢å¤');
    
    try {
      // åˆ›å»ºå¤‡ä»½æ•°æ®
      const backupData = {
        timestamp: Date.now(),
        guestId: this.guestId,
        data: {
          vocabulary: ['backup_word_1', 'backup_word_2'],
          userStats: { totalWords: 2, accuracy: 0.8 }
        }
      };
      
      const backupKey = `guest_backup_${this.guestId}_${backupData.timestamp}`;
      await AsyncStorage.setItem(backupKey, JSON.stringify(backupData));
      
      // éªŒè¯å¤‡ä»½
      const storedBackup = await AsyncStorage.getItem(backupKey);
      const parsedBackup = JSON.parse(storedBackup);
      
      const backupValid = parsedBackup.guestId === this.guestId && 
                         parsedBackup.data.vocabulary.length === 2;
      
      this.testResults.push({
        test: 'å¤‡ä»½æ¢å¤',
        passed: backupValid,
        details: `å¤‡ä»½å¤§å°: ${storedBackup.length}å­—èŠ‚, åŒ…å« ${Object.keys(parsedBackup.data).length} ç§æ•°æ®ç±»å‹`
      });
      
      console.log(`âœ… å¤‡ä»½æ¢å¤: ${backupValid ? 'é€šè¿‡' : 'å¤±è´¥'}`);
      
    } catch (error) {
      this.testResults.push({
        test: 'å¤‡ä»½æ¢å¤',
        passed: false,
        details: error.message
      });
      console.log('âŒ å¤‡ä»½æ¢å¤æµ‹è¯•å¤±è´¥:', error.message);
    }
  }

  async testResetFunctionality() {
    console.log('\nğŸ“‹ æµ‹è¯•7: é‡ç½®åŠŸèƒ½');
    
    try {
      // è®°å½•é‡ç½®å‰çš„æ•°æ®é¡¹æ•°é‡
      const allKeysBefore = await AsyncStorage.getAllKeys();
      const guestKeysBefore = allKeysBefore.filter(key => key.startsWith(`guest_${this.guestId}_`));
      
      // æ¨¡æ‹Ÿé‡ç½®ï¼ˆæ¸…é™¤æ¸¸å®¢æ•°æ®ï¼‰
      const allKeys = await AsyncStorage.getAllKeys();
      const guestKeys = allKeys.filter(key => key.startsWith(`guest_${this.guestId}_`));
      
      if (guestKeys.length > 0) {
        await AsyncStorage.multiRemove(guestKeys);
      }
      
      // éªŒè¯é‡ç½®ç»“æœ
      const allKeysAfter = await AsyncStorage.getAllKeys();
      const guestKeysAfter = allKeysAfter.filter(key => key.startsWith(`guest_${this.guestId}_`));
      
      const resetSuccessful = guestKeysAfter.length === 0 && guestKeysBefore.length > 0;
      
      this.testResults.push({
        test: 'é‡ç½®åŠŸèƒ½',
        passed: resetSuccessful,
        details: `é‡ç½®å‰: ${guestKeysBefore.length}é¡¹, é‡ç½®å: ${guestKeysAfter.length}é¡¹`
      });
      
      console.log(`âœ… é‡ç½®åŠŸèƒ½: ${resetSuccessful ? 'é€šè¿‡' : 'å¤±è´¥'}`);
      
    } catch (error) {
      this.testResults.push({
        test: 'é‡ç½®åŠŸèƒ½',
        passed: false,
        details: error.message
      });
      console.log('âŒ é‡ç½®åŠŸèƒ½æµ‹è¯•å¤±è´¥:', error.message);
    }
  }

  generateTestReport() {
    console.log('\nğŸ“Š æ¸¸å®¢æ¨¡å¼æµ‹è¯•æŠ¥å‘Š');
    console.log('='.repeat(50));
    
    const passedTests = this.testResults.filter(result => result.passed);
    const failedTests = this.testResults.filter(result => !result.passed);
    
    console.log(`æ€»æµ‹è¯•æ•°: ${this.testResults.length}`);
    console.log(`é€šè¿‡: ${passedTests.length}`);
    console.log(`å¤±è´¥: ${failedTests.length}`);
    console.log(`æˆåŠŸç‡: ${((passedTests.length / this.testResults.length) * 100).toFixed(1)}%`);
    
    console.log('\nğŸ“‹ è¯¦ç»†ç»“æœ:');
    this.testResults.forEach((result, index) => {
      const status = result.passed ? 'âœ…' : 'âŒ';
      console.log(`${index + 1}. ${status} ${result.test}: ${result.details}`);
    });
    
    if (failedTests.length > 0) {
      console.log('\nâš ï¸ å¤±è´¥æµ‹è¯•è¯¦æƒ…:');
      failedTests.forEach(test => {
        console.log(`- ${test.test}: ${test.details}`);
      });
    }
    
    if (passedTests.length === this.testResults.length) {
      console.log('\nğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼æ¸¸å®¢æ¨¡å¼åŠŸèƒ½å®Œå…¨æ­£å¸¸');
    } else {
      console.log('\nâš ï¸ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦æ£€æŸ¥ç›¸å…³åŠŸèƒ½');
    }
  }
}

// è¿è¡Œæµ‹è¯•
async function runTests() {
  const tester = new GuestModeTester();
  await tester.runAllTests();
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤è„šæœ¬
if (require.main === module) {
  runTests().catch(console.error);
}

module.exports = GuestModeTester; 